////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include "SpellAuraDefines.h"
#include "SpellInfo.h"
#include "SpellMgr.h"
#include "Spell.h"
#include "DBCStores.h"
#include "DB2Stores.h"
#include "ConditionMgr.h"
#include "Vehicle.h"
#include "Group.h"
#include "CreatureAI.h"

uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
{
    switch (objType)
    {
        case TARGET_OBJECT_TYPE_DEST:
            return TARGET_FLAG_DEST_LOCATION;
        case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
            return TARGET_FLAG_DEST_LOCATION | TARGET_FLAG_UNIT;
        case TARGET_OBJECT_TYPE_CORPSE_ALLY:
            return TARGET_FLAG_CORPSE_ALLY;
        case TARGET_OBJECT_TYPE_CORPSE_ENEMY:
            return TARGET_FLAG_CORPSE_ENEMY;
        case TARGET_OBJECT_TYPE_CORPSE:
            return TARGET_FLAG_CORPSE_ALLY | TARGET_FLAG_CORPSE_ENEMY;
        case TARGET_OBJECT_TYPE_UNIT:
            return TARGET_FLAG_UNIT;
        case TARGET_OBJECT_TYPE_GOBJ:
            return TARGET_FLAG_GAMEOBJECT;
        case TARGET_OBJECT_TYPE_GOBJ_ITEM:
            return TARGET_FLAG_GAMEOBJECT_ITEM;
        case TARGET_OBJECT_TYPE_ITEM:
            return TARGET_FLAG_ITEM;
        case TARGET_OBJECT_TYPE_SRC:
            return TARGET_FLAG_SOURCE_LOCATION;
        default:
            return TARGET_FLAG_NONE;
    }
}

SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
{
    _target = Targets(target);
}

bool SpellImplicitTargetInfo::IsArea() const
{
    return GetSelectionCategory() == TARGET_SELECT_CATEGORY_AREA || GetSelectionCategory() == TARGET_SELECT_CATEGORY_CONE;
}

SpellTargetSelectionCategories SpellImplicitTargetInfo::GetSelectionCategory() const
{
    return _data[_target].SelectionCategory;
}

SpellTargetReferenceTypes SpellImplicitTargetInfo::GetReferenceType() const
{
    return _data[_target].ReferenceType;
}

SpellTargetObjectTypes SpellImplicitTargetInfo::GetObjectType() const
{
    return _data[_target].ObjectType;
}

SpellTargetCheckTypes SpellImplicitTargetInfo::GetCheckType() const
{
    return _data[_target].SelectionCheckType;
}

SpellTargetDirectionTypes SpellImplicitTargetInfo::GetDirectionType() const
{
    return _data[_target].DirectionType;
}

float SpellImplicitTargetInfo::CalcDirectionAngle() const
{
    switch (GetDirectionType())
    {
        case TARGET_DIR_FRONT:
            return 0.0f;
        case TARGET_DIR_BACK:
            return static_cast<float>(M_PI);
        case TARGET_DIR_RIGHT:
            return static_cast<float>(-M_PI/2);
        case TARGET_DIR_LEFT:
            return static_cast<float>(M_PI/2);
        case TARGET_DIR_FRONT_RIGHT:
            return static_cast<float>(-M_PI/4);
        case TARGET_DIR_BACK_RIGHT:
            return static_cast<float>(-3*M_PI/4);
        case TARGET_DIR_BACK_LEFT:
            return static_cast<float>(3*M_PI/4);
        case TARGET_DIR_FRONT_LEFT:
            return static_cast<float>(M_PI/4);
        case TARGET_DIR_RANDOM:
            return float(rand_norm())*static_cast<float>(2*M_PI);
        default:
            return 0.0f;
    }
}

Targets SpellImplicitTargetInfo::GetTarget() const
{
    return _target;
}

uint32 SpellImplicitTargetInfo::GetExplicitTargetMask(bool& srcSet, bool& dstSet) const
{
    if (_target >= TOTAL_SPELL_TARGETS)
    {
        printf("SPELL_TARGET overflow!! %d\r\n", _target); ///< Bad sprintf :'(
        return 0;
    }

    uint32 targetMask = 0;
    if (GetTarget() == TARGET_DEST_TRAJ)
    {
        if (!srcSet)
            targetMask = TARGET_FLAG_SOURCE_LOCATION;
        if (!dstSet)
            targetMask |= TARGET_FLAG_DEST_LOCATION;
    }
    else
    {
        switch (GetReferenceType())
        {
            case TARGET_REFERENCE_TYPE_SRC:
                if (srcSet)
                    break;
                targetMask = TARGET_FLAG_SOURCE_LOCATION;
                break;
            case TARGET_REFERENCE_TYPE_DEST:
                if (dstSet)
                    break;
                targetMask = TARGET_FLAG_DEST_LOCATION;
                break;
            case TARGET_REFERENCE_TYPE_TARGET:
                switch (GetObjectType())
                {
                    case TARGET_OBJECT_TYPE_GOBJ:
                        targetMask = TARGET_FLAG_GAMEOBJECT;
                        break;
                    case TARGET_OBJECT_TYPE_GOBJ_ITEM:
                        targetMask = TARGET_FLAG_GAMEOBJECT_ITEM;
                        break;
                    case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
                    case TARGET_OBJECT_TYPE_UNIT:
                    case TARGET_OBJECT_TYPE_DEST:
                        switch (GetCheckType())
                        {
                            case TARGET_CHECK_ENEMY:
                                targetMask = TARGET_FLAG_UNIT_ENEMY;
                                break;
                            case TARGET_CHECK_ALLY:
                            case TARGET_CHECK_ALLY_OR_RAID:
                                targetMask = TARGET_FLAG_UNIT_ALLY;
                                break;
                            case TARGET_CHECK_PARTY:
                                targetMask = TARGET_FLAG_UNIT_PARTY;
                                break;
                            case TARGET_CHECK_RAID:
                                targetMask = TARGET_FLAG_UNIT_RAID;
                                break;
                            case TARGET_CHECK_PASSENGER:
                                targetMask = TARGET_FLAG_UNIT_PASSENGER;
                                break;
                            case TARGET_CHECK_RAID_CLASS:
                            default:
                                targetMask = TARGET_FLAG_UNIT;
                                break;
                        }
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    }

    switch (GetObjectType())
    {
        case TARGET_OBJECT_TYPE_SRC:
            srcSet = true;
            break;
        case TARGET_OBJECT_TYPE_DEST:
        case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
            dstSet = true;
            break;
        default:
            break;
    }
    return targetMask;
}

SpellImplicitTargetInfo::StaticData  SpellImplicitTargetInfo::_data[TOTAL_SPELL_TARGETS] =
{
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 0
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 1 TARGET_UNIT_CASTER
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 2 TARGET_UNIT_NEARBY_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 3 TARGET_UNIT_NEARBY_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 4 TARGET_UNIT_NEARBY_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 5 TARGET_UNIT_PET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 6 TARGET_UNIT_TARGET_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 7 TARGET_UNIT_SRC_AREA_ENTRY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 8 TARGET_UNIT_DEST_AREA_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 9 TARGET_DEST_HOME
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 10
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 11 TARGET_UNIT_SRC_AREA_UNK_11
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 12
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 13
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 14
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 15 TARGET_UNIT_SRC_AREA_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 16 TARGET_UNIT_DEST_AREA_ENEMY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 17 TARGET_DEST_DB
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 18 TARGET_DEST_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 19
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 20 TARGET_UNIT_CASTER_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 21 TARGET_UNIT_TARGET_ALLY
    { TARGET_OBJECT_TYPE_SRC,       TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 22 TARGET_SRC_CASTER
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 23 TARGET_GAMEOBJECT_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 24 TARGET_UNIT_CONE_ENEMY_24
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 25 TARGET_UNIT_TARGET_ANY
    { TARGET_OBJECT_TYPE_GOBJ_ITEM, TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 26 TARGET_GAMEOBJECT_ITEM_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 27 TARGET_UNIT_MASTER
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 28 TARGET_DEST_DYNOBJ_ENEMY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 29 TARGET_DEST_DYNOBJ_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 30 TARGET_UNIT_SRC_AREA_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 31 TARGET_UNIT_DEST_AREA_ALLY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 32 TARGET_DEST_CASTER_SUMMON
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 33 TARGET_UNIT_SRC_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 34 TARGET_UNIT_DEST_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 35 TARGET_UNIT_TARGET_PARTY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 36 TARGET_DEST_CASTER_UNK_36
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_LAST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 37 TARGET_UNIT_LASTTARGET_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 38 TARGET_UNIT_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 39 TARGET_DEST_CASTER_FISHING
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 40 TARGET_GAMEOBJECT_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 41 TARGET_DEST_CASTER_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 42 TARGET_DEST_CASTER_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 43 TARGET_DEST_CASTER_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 44 TARGET_DEST_CASTER_FRONT_LEFT
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 45 TARGET_UNIT_TARGET_CHAINHEAL_ALLY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 46 TARGET_DEST_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 47 TARGET_DEST_CASTER_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 48 TARGET_DEST_CASTER_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 49 TARGET_DEST_CASTER_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 50 TARGET_DEST_CASTER_LEFT
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 51 TARGET_GAMEOBJECT_SRC_AREA
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 52 TARGET_GAMEOBJECT_DEST_AREA
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 53 TARGET_DEST_TARGET_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 54 TARGET_UNIT_CONE_ENEMY_54
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 55 TARGET_DEST_CASTER_FRONT_LEAP
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 56 TARGET_UNIT_CASTER_AREA_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 57 TARGET_UNIT_TARGET_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,  TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 58 TARGET_UNIT_NEARBY_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_RAID,          TARGET_DIR_FRONT        },  ///< 59 TARGET_UNIT_CONE_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENTRY,         TARGET_DIR_FRONT        },  ///< 60 TARGET_UNIT_CONE_ENTRY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_RAID_CLASS,    TARGET_DIR_NONE         },  ///< 61 TARGET_UNIT_TARGET_AREA_RAID_CLASS
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 62 TARGET_UNK_62
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 63 TARGET_DEST_TARGET_ANY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 64 TARGET_DEST_TARGET_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 65 TARGET_DEST_TARGET_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 66 TARGET_DEST_TARGET_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 67 TARGET_DEST_TARGET_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 68 TARGET_DEST_TARGET_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 69 TARGET_DEST_TARGET_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 70 TARGET_DEST_TARGET_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 71 TARGET_DEST_TARGET_FRONT_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 72 TARGET_DEST_CASTER_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 73 TARGET_DEST_CASTER_RADIUS
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 74 TARGET_DEST_TARGET_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 75 TARGET_DEST_TARGET_RADIUS
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 76 TARGET_DEST_CHANNEL_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 77 TARGET_UNIT_CHANNEL_TARGET
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 78 TARGET_DEST_DEST_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 79 TARGET_DEST_DEST_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 80 TARGET_DEST_DEST_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 81 TARGET_DEST_DEST_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 82 TARGET_DEST_DEST_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 83 TARGET_DEST_DEST_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 84 TARGET_DEST_DEST_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 85 TARGET_DEST_DEST_FRONT_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 86 TARGET_DEST_DEST_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 87 TARGET_DEST_DEST
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 88 TARGET_DEST_DYNOBJ_NONE
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 89 TARGET_DEST_TRAJ
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 90 TARGET_UNIT_TARGET_MINIPET
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 91 TARGET_DEST_DEST_RADIUS
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 92 TARGET_UNIT_SUMMONER
    { TARGET_OBJECT_TYPE_CORPSE,    TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 93 TARGET_CORPSE_SRC_AREA_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 94 TARGET_UNIT_VEHICLE
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_PASSENGER,     TARGET_DIR_NONE         },  ///< 95 TARGET_UNIT_TARGET_PASSENGER
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 96 TARGET_UNIT_PASSENGER_0
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 97 TARGET_UNIT_PASSENGER_1
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 98 TARGET_UNIT_PASSENGER_2
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 99 TARGET_UNIT_PASSENGER_3
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 100 TARGET_UNIT_PASSENGER_4
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 101 TARGET_UNIT_PASSENGER_5
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 102 TARGET_UNIT_PASSENGER_6
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 103 TARGET_UNIT_PASSENGER_7
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 104 TARGET_UNIT_CONE_ENEMY_104
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 105 TARGET_UNIT_UNK_105
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL, TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 106 TARGET_DEST_CHANNEL_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 107 TARGET_DEST_EXTRA_TARGETS
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 108 TARGET_GAMEOBJECT_CONE
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 109
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 110 TARGET_UNIT_CONE_ENEMY_110
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 111
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 112
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 113
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 114
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 115
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 116
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 117
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT, TARGET_CHECK_ALLY_OR_RAID,  TARGET_DIR_NONE         },  ///< 118 TARGET_UNIT_ALLY_OR_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 119
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 120
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 121
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 122
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 123
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 124
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 125
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 126
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 127
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 128
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 129 TARGET_UNIT_CONE_ENEMY_129
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 130 TARGET_UNIT_CONE_ENEMY_130
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 131
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 132
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 133
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 134
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 135
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 136
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 137
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 138
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 139
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 140
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 141
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 142
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,    TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 143 TARGET_ENNEMIES_AROUND_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 144
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 145
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 146
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 147
};

SpellEffectInfo::SpellEffectInfo(SpellEntry const* spellEntry, SpellInfo const* spellInfo, uint8 effIndex, uint32 difficulty)
{
    auto l_Effect    = spellEntry->GetSpellEffect(effIndex, difficulty);
    auto l_Scaling   = GetSpellEffectScalingEntry(l_Effect ? l_Effect->Id : 0);
    auto l_GroupSize = sSpellEffectGroupSizeStore.LookupEntry(l_Effect ? l_Effect->Id : 0);

    _spellInfo = spellInfo;
    _effIndex = effIndex;
    Effect = l_Effect ? l_Effect->Effect : 0;
    ApplyAuraName = l_Effect ? l_Effect->EffectApplyAuraName : 0;
    Amplitude = l_Effect ? l_Effect->EffectAmplitude : 0;
    DieSides = l_Effect ? l_Effect->EffectDieSides : 0;
    RealPointsPerLevel = l_Effect ? l_Effect->EffectRealPointsPerLevel : 0.0f;
    BasePoints = l_Effect ? l_Effect->EffectBasePoints : 0;
    PointsPerComboPoint = l_Effect ? l_Effect->EffectPointsPerComboPoint : 0.0f;
    ValueMultiplier = l_Effect ? l_Effect->EffectValueMultiplier : 0.0f;
    DamageMultiplier = l_Effect ? l_Effect->EffectDamageMultiplier : 0.0f;
    BonusMultiplier = l_Effect ? l_Effect->EffectBonusMultiplier : 0.0f;
    MiscValue = l_Effect ? l_Effect->EffectMiscValue : 0;
    MiscValueB = l_Effect ? l_Effect->EffectMiscValueB : 0;
    Mechanic = Mechanics(l_Effect ? l_Effect->EffectMechanic : 0);
    TargetA = SpellImplicitTargetInfo(l_Effect ? l_Effect->EffectImplicitTargetA : 0);
    TargetB = SpellImplicitTargetInfo(l_Effect ? l_Effect->EffectImplicitTargetB : 0);
    RadiusEntry = l_Effect && l_Effect->EffectRadiusIndex ? sSpellRadiusStore.LookupEntry(l_Effect->EffectRadiusIndex) : NULL;
    if (!RadiusEntry)
         RadiusEntry = l_Effect && l_Effect->EffectRadiusMaxIndex ? sSpellRadiusStore.LookupEntry(l_Effect->EffectRadiusMaxIndex) : NULL;
    ChainTarget = l_Effect ? l_Effect->EffectChainTarget : 0;
    ItemType = l_Effect ? l_Effect->EffectItemType : 0;
    TriggerSpell = l_Effect ? l_Effect->EffectTriggerSpell : 0;
    SpellClassMask = l_Effect ? l_Effect->EffectSpellClassMask : flag128(0);
    ImplicitTargetConditions = NULL;
    ScalingMultiplier = l_Scaling ? l_Scaling->Multiplier : 0.0f;
    DeltaScalingMultiplier = l_Scaling ? l_Scaling->RandomMultiplier : 0.0f;
    ComboScalingMultiplier = l_Scaling ? l_Scaling->OtherMultiplier: 0.0f;
    AttackPowerMultiplier = l_Effect ? l_Effect->BonusCoefficientFromAP : 0.0f;
    GroupSizeCoefficient = l_GroupSize ? l_GroupSize->Coefficient : 0.0f;
}

bool SpellEffectInfo::IsEffect() const
{
    return Effect != 0;
}

bool SpellEffectInfo::IsEffect(SpellEffects effectName) const
{
    return Effect == uint32(effectName);
}

bool SpellEffectInfo::IsAura() const
{
    return (IsUnitOwnedAuraEffect() || Effect == SPELL_EFFECT_PERSISTENT_AREA_AURA) && ApplyAuraName != 0;
}

bool SpellEffectInfo::IsPersistenAura() const
{
    return Effect == SPELL_EFFECT_PERSISTENT_AREA_AURA && ApplyAuraName != 0;
}

bool SpellEffectInfo::IsAura(AuraType aura) const
{
    return IsAura() && AuraType(ApplyAuraName) == uint32(aura);
}

bool SpellEffectInfo::IsTargetingArea() const
{
    return TargetA.IsArea() || TargetB.IsArea();
}

bool SpellEffectInfo::IsAreaAuraEffect() const
{
    if (Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY    ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID     ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_FRIEND   ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_ENEMY    ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_PET      ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_OWNER)
        return true;
    return false;
}

bool SpellEffectInfo::IsFarUnitTargetEffect() const
{
    return (Effect == SPELL_EFFECT_SUMMON_PLAYER)
        || (Effect == SPELL_EFFECT_SUMMON_RAF_FRIEND)
        || (Effect == SPELL_EFFECT_RESURRECT)
        || (Effect == SPELL_EFFECT_RESURRECT_NEW)
        || (Effect == SPELL_EFFECT_SKIN_PLAYER_CORPSE);
}

bool SpellEffectInfo::IsFarDestTargetEffect() const
{
    return Effect == SPELL_EFFECT_TELEPORT_UNITS;
}

bool SpellEffectInfo::IsUnitOwnedAuraEffect() const
{
    return IsAreaAuraEffect() || Effect == SPELL_EFFECT_APPLY_AURA || Effect == SPELL_EFFECT_APPLY_AURA_ON_PET;
}

int32 SpellEffectInfo::CalcValue(Unit const* p_Caster, int32 const* p_Bp, Unit const* p_Target, int32 p_ItemLevel /*= -1*/, bool p_Log /*= false*/) const
{
    float l_BasePointsPerLevel = RealPointsPerLevel;
    int32 l_BasePoints = p_Bp ? *p_Bp : BasePoints;
    float l_ComboDamage = PointsPerComboPoint;

    // base amount modification based on spell lvl vs caster lvl
    if (ScalingMultiplier != 0.0f)
    {
        SpellScalingEntry const* l_SpellScaling = _spellInfo->GetSpellScaling();

        if (p_Caster && l_SpellScaling != nullptr)
        {
            int32 l_Level = p_Caster->getLevel();
            if (p_Target && _spellInfo->IsPositiveEffect(_effIndex) && (Effect == SPELL_EFFECT_APPLY_AURA || Effect == SPELL_EFFECT_APPLY_AURA_ON_PET))
                l_Level = p_Target->getLevel();

            float l_Multiplier = 0.0f;

            // Level scaling cap
            if (l_SpellScaling->MaxScalingLevel && uint32(l_Level) > l_SpellScaling->MaxScalingLevel)
                l_Level = l_SpellScaling->MaxScalingLevel;

            if (l_SpellScaling->ScalesFromItemLevel == 0)
            {
                if ((_spellInfo->AttributesEx11 & SPELL_ATTR11_SCALES_WITH_ITEM_LEVEL) == 0)
                {
                    int32 l_ScalingClassIndex = _spellInfo->ScalingClass;

                    if (_spellInfo->ScalingClass < 0)
                        l_ScalingClassIndex = (sChrClassesStore.GetNumRows() - 1) - _spellInfo->ScalingClass;

                    l_ScalingClassIndex -= 1;

                    uint32 l_GTSpellScalingRecID = l_ScalingClassIndex * GT_MAX_LEVEL + l_Level - 1;
                    GtSpellScalingEntry const* l_GtScaling = sGtSpellScalingStore.LookupEntry(l_GTSpellScalingRecID);

                    if (l_GtScaling)
                        l_Multiplier = l_GtScaling->value;
                }
                else
                {
                    RandomPropertiesPointsEntry const* l_RandomPropertiesPoints = sRandomPropertiesPointsStore.LookupEntry(p_ItemLevel);
                    if (l_RandomPropertiesPoints)
                        l_Multiplier = l_RandomPropertiesPoints->RarePropertiesPoints[0];
                }
            }
            else
            {
                RandomPropertiesPointsEntry const* l_RandomPropertiesPoints = sRandomPropertiesPointsStore.LookupEntry(l_SpellScaling->ScalesFromItemLevel);
                if (l_RandomPropertiesPoints)
                    l_Multiplier = l_RandomPropertiesPoints->RarePropertiesPoints[0];
            }

            if (_spellInfo->CastTimeMax > 0 && _spellInfo->CastTimeMaxLevel > l_Level)
                l_Multiplier *= float(_spellInfo->CastTimeMin + (l_Level - 1) * (_spellInfo->CastTimeMax - _spellInfo->CastTimeMin) / (_spellInfo->CastTimeMaxLevel - 1)) / float(_spellInfo->CastTimeMax);
            if (_spellInfo->NerfMaxLevel > l_Level)
                l_Multiplier *= (1.0f - _spellInfo->NerfFactor) * (float)(l_Level - 1) / (float)(_spellInfo->NerfMaxLevel - 1) + _spellInfo->NerfFactor;

            float l_PreciseBasePoints = ScalingMultiplier * l_Multiplier;
            if (DeltaScalingMultiplier)
            {
                float l_Delta = DeltaScalingMultiplier * ScalingMultiplier * l_Multiplier * 0.5f;
                l_PreciseBasePoints += frand(-l_Delta, l_Delta);
            }

            l_BasePoints = int32(round(l_PreciseBasePoints));

            if (ComboScalingMultiplier)
                l_ComboDamage = ComboScalingMultiplier * l_Multiplier;
        }
    }
    else
    {
        if (p_Caster)
        {
            int32 l_Level = int32(p_Caster->getLevel());
            if (l_Level > int32(_spellInfo->MaxLevel) && _spellInfo->MaxLevel > 0)
                l_Level = int32(_spellInfo->MaxLevel);
            else if (l_Level < int32(_spellInfo->BaseLevel))
                l_Level = int32(_spellInfo->BaseLevel);
            l_Level -= int32(_spellInfo->SpellLevel);
            l_BasePoints += int32(l_Level * l_BasePointsPerLevel);

            if (l_BasePointsPerLevel && l_BasePoints >= 100 && (Effect == SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT || ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE_PERCENT))  // Temporary
                l_BasePoints /= 10;
        }

        // roll in a range <1;EffectDieSides> as of patch 3.3.3
        int32 l_RandomPoints = int32(DieSides);
        switch (l_RandomPoints)
        {
            case 0: break;
            case 1: l_BasePoints += 1; break;                     // range 1..1
            default:
            {
                // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
                int32 randvalue = (l_RandomPoints >= 1)
                    ? irand(1, l_RandomPoints)
                    : irand(l_RandomPoints, 1);

                l_BasePoints += randvalue;
                break;
            }
        }
    }

    float l_Value = float(l_BasePoints);

    /// Apply group size scaling (since MoP 5.4 - SoO)
    if (GroupSizeCoefficient > 1.0f && p_Caster && p_Caster->GetMap()->IsRaid())
    {
        /// Get the group size
        int32 l_GroupSize = p_Caster->GetMap()->GetPlayersCountExceptGMs();

        /// Apply group size limit (min size is 10, max 30)
        l_GroupSize = std::min((int32)GroupScalingRange::Max, std::max(l_GroupSize, (int32)GroupScalingRange::Min));

        /// Compute the group size scaling value
        float l_GroupSizeCoefficient = (GroupSizeCoefficient - 1.0f) / ((int32)GroupScalingRange::Max - (int32)GroupScalingRange::Min);
        float l_GroupScalingValue    = l_GroupSizeCoefficient * (l_GroupSize - (int32)GroupScalingRange::Min) * l_Value;

        /// Add the group scaling bonus to the value
        l_Value += l_GroupScalingValue;
    }

    // random damage
    if (p_Caster)
    {
        /// Bonus amount from combo points
        if (p_Caster && l_ComboDamage)
            l_Value += l_ComboDamage * p_Caster->GetPower(Powers::POWER_COMBO_POINT);

        l_Value = p_Caster->ApplyEffectModifiers(_spellInfo, _effIndex, l_Value);

        // amount multiplication based on caster's level
        if (!_spellInfo->GetSpellScaling() && !l_BasePointsPerLevel && (_spellInfo->Attributes & SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION && _spellInfo->SpellLevel) &&
                Effect != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
                Effect != SPELL_EFFECT_KNOCK_BACK &&
                Effect != SPELL_EFFECT_ADD_EXTRA_ATTACKS &&
                Effect != SPELL_EFFECT_GAMEOBJECT_DAMAGE &&
                ApplyAuraName != SPELL_AURA_MOD_SPEED_ALWAYS &&
                ApplyAuraName != SPELL_AURA_MOD_SPEED_NOT_STACK &&
                ApplyAuraName != SPELL_AURA_MOD_INCREASE_SPEED &&
                ApplyAuraName != SPELL_AURA_MOD_DECREASE_SPEED)
                //there are many more: slow speed, -healing pct
            l_Value *= 0.25f * exp(p_Caster->getLevel() * (70 - _spellInfo->SpellLevel) / 1000.0f);
            //value = int32(value * (int32)getLevel() / (int32)(_spellInfo->spellLevel ? _spellInfo->spellLevel : 1));

        if (CanScale())
        {
            bool l_RangedClass = _spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && _spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MAGIC && p_Caster->getClass() == CLASS_HUNTER;
            WeaponAttackType l_AttType = (_spellInfo->IsRangedWeaponSpell() && l_RangedClass) ? WeaponAttackType::RangedAttack : WeaponAttackType::BaseAttack;
            float l_AttackPower = p_Caster->GetTotalAttackPowerValue(l_AttType);
            float l_SpellPower = p_Caster->SpellBaseDamageBonusDone(_spellInfo->GetSchoolMask());

            {
                if (l_AttackPower == 0.0f)
                    l_AttackPower = p_Caster->GetTotalAttackPowerValue(WeaponAttackType::BaseAttack);
                if (l_AttackPower == 0.0f && p_Caster->GetOwner() && p_Caster->GetOwner()->ToPlayer())
                    l_AttackPower = p_Caster->GetOwner()->GetTotalAttackPowerValue(l_AttType);
            }

            {
                if (l_SpellPower == 0.0f)
                    l_SpellPower = p_Caster->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);
                if (l_SpellPower == 0.0f && p_Caster->GetOwner() && p_Caster->GetOwner()->ToPlayer())
                    l_SpellPower = p_Caster->GetOwner()->SpellBaseDamageBonusDone(_spellInfo->GetSchoolMask());
            }

            float l_APBonusDamage = l_AttackPower * AttackPowerMultiplier;
            float l_SPBonusDamage = l_SpellPower * BonusMultiplier;

            if (p_Log && AttackPowerMultiplier)
                LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(CanScale): Spell %s: EffIndex %i: AttackPowerMultiplier %f * AttackPower %f = %f, Base %f", _spellInfo->GetNameForLogging().c_str(), _effIndex, AttackPowerMultiplier, l_AttackPower, l_APBonusDamage, l_Value);

            if (p_Log && BonusMultiplier)
                LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(CanScale): Spell %s: EffIndex %i: BonusMultiplier %f * SpellPower %f = %f, Base %f", _spellInfo->GetNameForLogging().c_str(), _effIndex, BonusMultiplier, l_SpellPower, l_SPBonusDamage, l_Value);

            l_Value += l_APBonusDamage + l_SPBonusDamage;
        }
    }

    /// Don't need to change our value for Arcane Barrage triggered spell and Mangle (bear), it's already calculated
    if (_spellInfo->Id == 50273 || _spellInfo->Id == 33917)
        l_Value = float(l_BasePoints);

    if (p_Log)
        LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(): Spell %s: EffIndex %i: Final Amount %i", _spellInfo->GetNameForLogging().c_str(), _effIndex, int32(l_Value));

    return int32(l_Value);
}

int32 SpellEffectInfo::CalcBaseValue(int32 value) const
{
    if (DieSides == 0)
        return value;
    else
        return value - 1;
}

float SpellEffectInfo::CalcValueMultiplier(Unit* caster, Spell* spell) const
{
    float multiplier = ValueMultiplier;
    if (Player* modOwner = (caster ? caster->GetSpellModOwner() : NULL))
        modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
    return multiplier;
}

float SpellEffectInfo::CalcDamageMultiplier(Unit* p_Caster, Spell* p_Spell) const
{
    float l_Multiplier = DamageMultiplier * 100.0f;

    if (Player* l_ModOwner = (p_Caster ? p_Caster->GetSpellModOwner() : nullptr))
        l_ModOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_DAMAGE_MULTIPLIER, l_Multiplier, p_Spell);

    return l_Multiplier / 100.0f;
}

bool SpellEffectInfo::HasRadius() const
{
    return RadiusEntry != nullptr;
}

float SpellEffectInfo::CalcRadius(Unit* caster, Spell* spell) const
{
    if (!HasRadius())
        return 0.0f;

    float radius = _spellInfo->IsPositive() ? RadiusEntry->radiusFriend : RadiusEntry->radiusHostile;
    if (Player* modOwner = (caster ? caster->GetSpellModOwner() : nullptr))
        modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_RADIUS, radius, spell);

    return radius;
}

uint32 SpellEffectInfo::GetProvidedTargetMask() const
{
    return GetTargetFlagMask(TargetA.GetObjectType()) | GetTargetFlagMask(TargetB.GetObjectType());
}

void SpellEffectInfo::SetRadiusIndex(uint32 index)
{
    SpellRadiusEntry const* radiusIndex = sSpellRadiusStore.LookupEntry(index);
    if (!radiusIndex)
        return;

    RadiusEntry = radiusIndex;
}

uint32 SpellEffectInfo::GetMissingTargetMask(bool srcSet /*= false*/, bool dstSet /*= false*/, uint32 mask /*=0*/) const
{
    uint32 effImplicitTargetMask = GetTargetFlagMask(GetUsedTargetObjectType());
    uint32 providedTargetMask = GetTargetFlagMask(TargetA.GetObjectType()) | GetTargetFlagMask(TargetB.GetObjectType()) | mask;

    // remove all flags covered by effect target mask
    if (providedTargetMask & TARGET_FLAG_UNIT_MASK)
        effImplicitTargetMask &= ~(TARGET_FLAG_UNIT_MASK);
    if (providedTargetMask & TARGET_FLAG_CORPSE_MASK)
        effImplicitTargetMask &= ~(TARGET_FLAG_UNIT_MASK | TARGET_FLAG_CORPSE_MASK);
    if (providedTargetMask & TARGET_FLAG_GAMEOBJECT_ITEM)
        effImplicitTargetMask &= ~(TARGET_FLAG_GAMEOBJECT_ITEM | TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_ITEM);
    if (providedTargetMask & TARGET_FLAG_GAMEOBJECT)
        effImplicitTargetMask &= ~(TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_GAMEOBJECT_ITEM);
    if (providedTargetMask & TARGET_FLAG_ITEM)
        effImplicitTargetMask &= ~(TARGET_FLAG_ITEM | TARGET_FLAG_GAMEOBJECT_ITEM);
    if (dstSet || providedTargetMask & TARGET_FLAG_DEST_LOCATION)
        effImplicitTargetMask &= ~(TARGET_FLAG_DEST_LOCATION);
    if (srcSet || providedTargetMask & TARGET_FLAG_SOURCE_LOCATION)
        effImplicitTargetMask &= ~(TARGET_FLAG_SOURCE_LOCATION);

    return effImplicitTargetMask;
}

SpellEffectImplicitTargetTypes SpellEffectInfo::GetImplicitTargetType() const
{
    return _data[Effect].ImplicitTargetType;
}

SpellTargetObjectTypes SpellEffectInfo::GetUsedTargetObjectType() const
{
    return _data[Effect].UsedTargetObjectType;
}

SpellEffectInfo::StaticData  SpellEffectInfo::_data[TOTAL_SPELL_EFFECTS] =
{
    // implicit target type           used target object type
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 0
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 1 SPELL_EFFECT_INSTAKILL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 2 SPELL_EFFECT_SCHOOL_DAMAGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 3 SPELL_EFFECT_DUMMY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 4 SPELL_EFFECT_PORTAL_TELEPORT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 5 SPELL_EFFECT_TELEPORT_UNITS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 6 SPELL_EFFECT_APPLY_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 8 SPELL_EFFECT_POWER_DRAIN
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 9 SPELL_EFFECT_HEALTH_LEECH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 10 SPELL_EFFECT_HEAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 11 SPELL_EFFECT_BIND
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 12 SPELL_EFFECT_PORTAL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 13 SPELL_EFFECT_RITUAL_BASE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 14 SPELL_EFFECT_RITUAL_SPECIALIZE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 16 SPELL_EFFECT_QUEST_COMPLETE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ALLY},   //< 18 SPELL_EFFECT_RESURRECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 20 SPELL_EFFECT_DODGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 21 SPELL_EFFECT_EVADE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 22 SPELL_EFFECT_PARRY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 23 SPELL_EFFECT_BLOCK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 24 SPELL_EFFECT_CREATE_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 25 SPELL_EFFECT_WEAPON
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 26 SPELL_EFFECT_DEFENSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 28 SPELL_EFFECT_SUMMON
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 29 SPELL_EFFECT_LEAP
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 30 SPELL_EFFECT_ENERGIZE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 32 SPELL_EFFECT_TRIGGER_MISSILE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ_ITEM},     //< 33 SPELL_EFFECT_OPEN_LOCK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 36 SPELL_EFFECT_LEARN_SPELL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 37 SPELL_EFFECT_SPELL_DEFENSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 38 SPELL_EFFECT_DISPEL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 39 SPELL_EFFECT_LANGUAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 40 SPELL_EFFECT_DUAL_WIELD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 41 SPELL_EFFECT_JUMP
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_DEST},          //< 42 SPELL_EFFECT_JUMP_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 44 SPELL_EFFECT_SKILL_STEP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 45 SPELL_EFFECT_PLAY_MOVIE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 46 SPELL_EFFECT_SPAWN
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 47 SPELL_EFFECT_TRADE_SKILL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 48 SPELL_EFFECT_STEALTH
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 49 SPELL_EFFECT_DETECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 50 SPELL_EFFECT_TRANS_DOOR
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 51 SPELL_EFFECT_FORCE_CRITICAL_HIT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 52 SPELL_EFFECT_GUARANTEE_HIT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 53 SPELL_EFFECT_ENCHANT_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 55 SPELL_EFFECT_TAMECREATURE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 56 SPELL_EFFECT_SUMMON_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 57 SPELL_EFFECT_LEARN_PET_SPELL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 58 SPELL_EFFECT_WEAPON_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 59 SPELL_EFFECT_CREATE_RANDOM_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 60 SPELL_EFFECT_PROFICIENCY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 61 SPELL_EFFECT_SEND_EVENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 62 SPELL_EFFECT_POWER_BURN
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 63 SPELL_EFFECT_THREAT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 64 SPELL_EFFECT_TRIGGER_SPELL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 66 SPELL_EFFECT_CREATE_MANA_GEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 67 SPELL_EFFECT_HEAL_MAX_HEALTH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 68 SPELL_EFFECT_INTERRUPT_CAST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 69 SPELL_EFFECT_DISTRACT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 70 SPELL_EFFECT_PULL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 71 SPELL_EFFECT_PICKPOCKET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 72 SPELL_EFFECT_ADD_FARSIGHT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 73 SPELL_EFFECT_UNTRAIN_TALENTS
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 74 SPELL_EFFECT_APPLY_GLYPH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 75 SPELL_EFFECT_HEAL_MECHANICAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 77 SPELL_EFFECT_SCRIPT_EFFECT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 78 SPELL_EFFECT_ATTACK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 79 SPELL_EFFECT_SANCTUARY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 80 SPELL_EFFECT_ADD_COMBO_POINTS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 81 SPELL_EFFECT_CREATE_HOUSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 82 SPELL_EFFECT_BIND_SIGHT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 83 SPELL_EFFECT_DUEL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 84 SPELL_EFFECT_STUCK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 85 SPELL_EFFECT_SUMMON_PLAYER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 86 SPELL_EFFECT_ACTIVATE_OBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 87 SPELL_EFFECT_GAMEOBJECT_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 88 SPELL_EFFECT_GAMEOBJECT_REPAIR
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 89 SPELL_EFFECT_GAMEOBJECT_SET_DESTRUCTION_STATE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 90 SPELL_EFFECT_KILL_CREDIT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 91 SPELL_EFFECT_THREAT_ALL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 93 SPELL_EFFECT_FORCE_DESELECT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 94 SPELL_EFFECT_SELF_RESURRECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 95 SPELL_EFFECT_SKINNING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 96 SPELL_EFFECT_CHARGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 97 SPELL_EFFECT_CAST_BUTTON
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 98 SPELL_EFFECT_KNOCK_BACK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 99 SPELL_EFFECT_DISENCHANT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 100 SPELL_EFFECT_INEBRIATE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 101 SPELL_EFFECT_FEED_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 102 SPELL_EFFECT_DISMISS_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 103 SPELL_EFFECT_REPUTATION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 108 SPELL_EFFECT_DISPEL_MECHANIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 109 SPELL_EFFECT_SUMMON_DEAD_PET
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 111 SPELL_EFFECT_DURABILITY_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 112 SPELL_EFFECT_112
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ALLY},   //< 113 SPELL_EFFECT_RESURRECT_NEW
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 114 SPELL_EFFECT_ATTACK_ME
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ENEMY},  //< 116 SPELL_EFFECT_SKIN_PLAYER_CORPSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 117 SPELL_EFFECT_SPIRIT_HEAL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 118 SPELL_EFFECT_SKILL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 119 SPELL_EFFECT_APPLY_AREA_AURA_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 120 SPELL_EFFECT_TELEPORT_GRAVEYARD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 122 SPELL_EFFECT_122
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 123 SPELL_EFFECT_SEND_TAXI
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 124 SPELL_EFFECT_PULL_TOWARDS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 127 SPELL_EFFECT_PROSPECTING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 130 SPELL_EFFECT_REDIRECT_THREAT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 131 SPELL_EFFECT_PLAY_SOUND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 132 SPELL_EFFECT_PLAY_MUSIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 133 SPELL_EFFECT_UNLEARN_SPECIALIZATION
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 134 SPELL_EFFECT_KILL_CREDIT2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 135 SPELL_EFFECT_CALL_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 136 SPELL_EFFECT_HEAL_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 137 SPELL_EFFECT_ENERGIZE_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 138 SPELL_EFFECT_LEAP_BACK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 139 SPELL_EFFECT_CLEAR_QUEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 140 SPELL_EFFECT_FORCE_CAST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 144 SPELL_EFFECT_KNOCK_BACK_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 145 SPELL_EFFECT_PULL_TOWARDS_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 146 SPELL_EFFECT_ACTIVATE_RUNE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 147 SPELL_EFFECT_QUEST_FAIL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 148 SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 149 SPELL_EFFECT_CHARGE_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 150 SPELL_EFFECT_QUEST_START
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 151 SPELL_EFFECT_TRIGGER_SPELL_2
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 152 SPELL_EFFECT_SUMMON_RAF_FRIEND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 153 SPELL_EFFECT_CREATE_TAMED_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 154 SPELL_EFFECT_DISCOVER_TAXI
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 155 SPELL_EFFECT_TITAN_GRIP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 157 SPELL_EFFECT_CREATE_ITEM_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 158 SPELL_EFFECT_MILLING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 159 SPELL_EFFECT_ALLOW_RENAME_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 160 SPELL_EFFECT_160
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 161 SPELL_EFFECT_TALENT_SPEC_COUNT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 162 SPELL_EFFECT_TALENT_SPEC_SELECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 163 SPELL_EFFECT_163
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 164 SPELL_EFFECT_REMOVE_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 165 SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 166 SPELL_EFFECT_GIVE_CURRENCY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 167 SPELL_EFFECT_UPDATE_PLAYER_PHASE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 168 SPELL_EFFECT_ALLOW_CONTROL_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 169 SPELL_EFFECT_DESTROY_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 170 SPELL_EFFECT_UPDATE_ZONE_AURAS_AND_PHASES
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 171 SPELL_EFFECT_SUMMON_OBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 172 SPELL_EFFECT_RESURRECT_WITH_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 173 SPELL_EFFECT_UNLOCK_GUILD_VAULT_TAB
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 174 SPELL_EFFECT_APPLY_AURA_ON_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 175 SPELL_EFFECT_175
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 176 SPELL_EFFECT_BECOME_UNTARGETTABLE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_AREATRIGGER},   //< 177 SPELL_EFFECT_DESPAWN_AREA_TRIGGER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 178 SPELL_EFFECT_178
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 179 SPELL_EFFECT_CREATE_AREATRIGGER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 180 SPELL_EFFECT_180
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 181 SPELL_EFFECT_UNLEARN_TALENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_AREATRIGGER},   //< 182 SPELL_EFFECT_DESPAWN_AREA_TRIGGER_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 183 SPELL_EFFECT_183
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 184 SPELL_EFFECT_REPUTATION_REWARD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 185 SPELL_EFFECT_PLAY_SCENEOBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 186 SPELL_EFFECT_PLAY_SCENEOBJECT_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 187 SPELL_EFFECT_187
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 188 SPELL_EFFECT_188
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 189 SPELL_EFFECT_LOOT_BONUS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 190 SPELL_EFFECT_190
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 191 SPELL_EFFECT_TELEPORT_TO_DIGSITE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 192 SPELL_EFFECT_UNCAGE_BATTLE_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 193 SPELL_EFFECT_193
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 194 SPELL_EFFECT_194
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 195 SPELL_EFFECT_195
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 196 SPELL_EFFECT_196
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 197 SPELL_EFFECT_197
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 198 SPELL_EFFECT_PLAY_CINEMATIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 199 SPELL_EFFECT_199
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 200 SPELL_EFFECT_RESURECT_BATTLE_PETS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 201 SPELL_EFFECT_CAN_PETBATTLE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 202 SPELL_EFFECT_202
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 203 SPELL_EFFECT_REMOVE_AURA_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 204 SPELL_EFFECT_204
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 205 SPELL_EFFECT_205
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 206 SPELL_EFFECT_206
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 207 SPELL_EFFECT_207
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 208 SPELL_EFFECT_208
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 209 SPELL_EFFECT_209
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 210 SPELL_EFFECT_LEARN_BLUE_PRINT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 211 SPELL_EFFECT_211
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 212 SPELL_EFFECT_212
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 213 SPELL_EFFECT_DEATH_GRIP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 214 SPELL_EFFECT_214
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 215 SPELL_EFFECT_UPGRADE_CHARACTER_SPELLS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 216 SPELL_EFFECT_216
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 217 SPELL_EFFECT_217
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 218 SPELL_EFFECT_218
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 219 SPELL_EFFECT_219
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 220 SPELL_EFFECT_220
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 221 SPELL_EFFECT_221
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 222 SPELL_EFFECT_222
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 223 SPELL_EFFECT_223
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 224 SPELL_EFFECT_GARRISON_FINALIZE_BUILDING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 225 SPELL_EFFECT_225
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 226 SPELL_EFFECT_226
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 227 SPELL_EFFECT_227
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 228 SPELL_EFFECT_228
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 229 SPELL_EFFECT_229
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 230 SPELL_EFFECT_230
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 231 SPELL_EFFECT_231
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 232 SPELL_EFFECT_232
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 233 SPELL_EFFECT_233
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 234 SPELL_EFFECT_234
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 235 SPELL_EFFECT_235
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 236 SPELL_EFFECT_236
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 237 SPELL_EFFECT_237
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 238 SPELL_EFFECT_238
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 239 SPELL_EFFECT_239
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 240 SPELL_EFFECT_240
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 241 SPELL_EFFECT_241
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 242 SPELL_EFFECT_242
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 243 SPELL_EFFECT_APPLY_ENCHANT_ILLUSION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 244 SPELL_EFFECT_244
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 245 SPELL_EFFECT_245
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 246 SPELL_EFFECT_246
};

SpellInfo::SpellInfo(SpellEntry const* p_SpellEntry, uint32 p_Difficulty, SpellVisualMap&& p_Visuals)
{
    Id = p_SpellEntry->Id;
    DifficultyID = p_Difficulty;
    AttributesCu = 0;

    SpellName = p_SpellEntry->SpellName;
    Rank = p_SpellEntry->Rank;
    RuneCostID = p_SpellEntry->runeCostID;
    SpellDifficultyId = 0;
    SpellScalingId = p_SpellEntry->SpellScalingId;
    SpellAuraOptionsId = p_SpellEntry->SpellAuraOptionsId;
    SpellAuraRestrictionsId = p_SpellEntry->SpellAuraRestrictionsId;
    SpellCastingRequirementsId = p_SpellEntry->SpellCastingRequirementsId;
    SpellCategoriesId = p_SpellEntry->SpellCategoriesId;
    SpellClassOptionsId = p_SpellEntry->SpellClassOptionsId;
    SpellCooldownsId = p_SpellEntry->SpellCooldownsId;
    SpellEquippedItemsId = p_SpellEntry->SpellEquippedItemsId;
    SpellInterruptsId = p_SpellEntry->SpellInterruptsId;
    SpellLevelsId = p_SpellEntry->SpellLevelsId;
    SpellReagentsId = p_SpellEntry->SpellReagentsId;
    SpellShapeshiftId = p_SpellEntry->SpellShapeshiftId;
    SpellTargetRestrictionsId = p_SpellEntry->SpellTargetRestrictionsId;
    SpellTotemsId = p_SpellEntry->SpellTotemsId;
    SpellMiscId = p_SpellEntry->SpellMiscId;

    // SpellDifficultyEntry
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
        Effects[i] = SpellEffectInfo(p_SpellEntry, this, i, p_Difficulty);

    UpdateSpellEffectCount();

    // SpellScalingEntry
    SpellScalingEntry const* _scaling = GetSpellScaling();
    CastTimeMin = _scaling ? _scaling->CastTimeMin : 0;
    CastTimeMax = _scaling ?_scaling->CastTimeMax : 0;
    CastTimeMaxLevel = _scaling ? _scaling->CastTimeMaxLevel : 0;
    ScalingClass = _scaling ? _scaling->ScalingClass : 0;
    NerfFactor = _scaling ? _scaling->NerfFactor : 0;
    NerfMaxLevel = _scaling ? _scaling->NerfMaxLevel : 0;

    // SpellAuraOptionsEntry
    SpellAuraOptionsEntry const* _options = GetSpellAuraOptions();
    SpellProcsPerMinuteEntry const* _ppm = _options ? sSpellProcsPerMinuteStore.LookupEntry(_options->ProcsPerMinuteEntry) : nullptr;
    ProcFlags = _options ? _options->procFlags : 0;
    ProcChance = _options ? _options->procChance : 0;
    ProcCharges = _options ? _options->procCharges : 0;
    InternalCooldown = _options ? _options->InternalCooldown : 0;
    ProcBasePPM = _ppm ? _ppm->BaseProcRate : 0.0f;
    if (_options)
        ProcPPMMods = GetSpellProcsPerMinuteMods(_options->ProcsPerMinuteEntry);
    StackAmount = _options ? _options->StackAmount : 0;

    // SpellAuraRestrictionsEntry
    SpellAuraRestrictionsEntry const* _aura = GetSpellAuraRestrictions();
    CasterAuraState = /*_aura ? _aura->CasterAuraState :*/ 0;
    TargetAuraState = /*_aura ? _aura->TargetAuraState :*/ 0;
    CasterAuraStateNot = _aura ? _aura->CasterAuraStateNot : 0;
    TargetAuraStateNot = _aura ? _aura->TargetAuraStateNot : 0;
    CasterAuraSpell = _aura ? _aura->casterAuraSpell : 0;
    TargetAuraSpell = _aura ? _aura->targetAuraSpell : 0;
    ExcludeCasterAuraSpell = _aura ? _aura->excludeCasterAuraSpell : 0;
    ExcludeTargetAuraSpell = _aura ? _aura->excludeTargetAuraSpell : 0;

    // SpellCastingRequirementsEntry
    SpellCastingRequirementsEntry const* _castreq = GetSpellCastingRequirements();
    RequiresSpellFocus = _castreq ? _castreq->RequiresSpellFocus : 0;
    FacingCasterFlags = _castreq ? _castreq->FacingCasterFlags : 0;
    AreaGroupId = _castreq ? _castreq->AreaGroupId : 0;

    // SpellCategoriesEntry
    SpellCategoriesEntry const* _categorie = GetSpellCategories();
    CategoryEntry = _categorie ? sSpellCategoryStore.LookupEntry(_categorie->Category) : NULL;
    Dispel = _categorie ? _categorie->Dispel : 0;
    Mechanic = _categorie ? _categorie->Mechanic : 0;
    StartRecoveryCategory = _categorie ? _categorie->StartRecoveryCategory : 0;
    DmgClass = _categorie ? _categorie->DmgClass : 0;
    PreventionType = _categorie ? _categorie->PreventionType : 0;
    ChargeCategoryEntry = _categorie ? sSpellCategoryStore.LookupEntry(_categorie->ChargeCategory) : 0;

    // SpellClassOptionsEntry
    SpellClassOptionsEntry const* _class = GetSpellClassOptions();
    SpellFamilyName = _class ? _class->SpellFamilyName : 0;
    SpellFamilyFlags = _class ? _class->SpellFamilyFlags : flag128(0);

    // SpellCooldownsEntry
    SpellCooldownsEntry const* _cooldowns = GetSpellCooldowns();
    RecoveryTime = _cooldowns ? _cooldowns->RecoveryTime : 0;
    CategoryRecoveryTime = _cooldowns ? _cooldowns->CategoryRecoveryTime : 0;
    StartRecoveryTime = _cooldowns ? _cooldowns->StartRecoveryTime : 0;

    // SpellEquippedItemsEntry
    SpellEquippedItemsEntry const* _equipped = GetSpellEquippedItems();
    EquippedItemClass = _equipped ? _equipped->EquippedItemClass : -1;
    EquippedItemSubClassMask = _equipped ?_equipped->EquippedItemSubClassMask : -1;
    EquippedItemInventoryTypeMask = _equipped ? _equipped->EquippedItemInventoryTypeMask : -1;

    // SpellInterruptsEntry
    SpellInterruptsEntry const* _interrupt = GetSpellInterrupts();
    InterruptFlags = _interrupt ? _interrupt->InterruptFlags : 0;
    AuraInterruptFlags = _interrupt ? _interrupt->AuraInterruptFlags : 0;
    ChannelInterruptFlags = _interrupt ? _interrupt->ChannelInterruptFlags : 0;

    // SpellLevelsEntry
    SpellLevelsEntry const* _levels = GetSpellLevels();
    MaxLevel = _levels ? _levels->maxLevel : 0;
    BaseLevel = _levels ? _levels->baseLevel : 0;
    SpellLevel = _levels ? _levels->spellLevel : 0;

    SpellPowers.clear();

    // SpellMiscEntry
    SpellMiscEntry const* _misc = GetSpellMisc();
    Attributes = _misc ? _misc->Attributes : 0;
    AttributesEx = _misc ? _misc->AttributesEx : 0;
    AttributesEx2 = _misc ? _misc->AttributesEx2 : 0;
    AttributesEx3 = _misc ? _misc->AttributesEx3 : 0;
    AttributesEx4 = _misc ? _misc->AttributesEx4 : 0;
    AttributesEx5 = _misc ? _misc->AttributesEx5 : 0;
    AttributesEx6 = _misc ? _misc->AttributesEx6 : 0;
    AttributesEx7 = _misc ? _misc->AttributesEx7 : 0;
    AttributesEx8 = _misc ? _misc->AttributesEx8 : 0;
    AttributesEx9 = _misc ? _misc->AttributesEx9 : 0;
    AttributesEx10 = _misc ? _misc->AttributesEx10 : 0;
    AttributesEx11 = _misc ? _misc->AttributesEx11 : 0;
    AttributesEx12 = _misc ? _misc->AttributesEx12 : 0;
    AttributesEx13 = _misc ? _misc->AttributesEx13 : 0;
    CastTimeEntry = _misc ? (_misc->CastingTimeIndex ? sSpellCastTimesStore.LookupEntry(_misc->CastingTimeIndex) : NULL) : NULL;
    DurationEntry = _misc ? (_misc->DurationIndex ? sSpellDurationStore.LookupEntry(_misc->DurationIndex) : NULL) : NULL;
    RangeEntry = _misc ? (_misc->rangeIndex ? sSpellRangeStore.LookupEntry(_misc->rangeIndex) : NULL) : NULL;
    Speed = _misc ? _misc->speed : 1.00f;

    memset(SpellVisual, 0, sizeof(SpellVisual));

    SpellIconID = _misc ? _misc->SpellIconID : 0;
    ActiveIconID = _misc ? _misc->activeIconID : 0;
    SchoolMask = _misc ? _misc->SchoolMask : 0;

    // SpellReagentsEntry
    SpellReagentsEntry const* _reagents = GetSpellReagents();
    for (uint8 i = 0; i < MAX_SPELL_REAGENTS; ++i)
        Reagent[i] = _reagents ? _reagents->Reagent[i] : 0;
    for (uint8 i = 0; i < MAX_SPELL_REAGENTS; ++i)
        ReagentCount[i] = _reagents ? _reagents->ReagentCount[i] : 0;

    SpellReagentsCurrencyEntry const* l_CurrencyReagents = sSpellReagentsCurrencyStore.LookupEntry(p_SpellEntry->Id);
    CurrencyID = l_CurrencyReagents ? l_CurrencyReagents->CurrencyID : 0;
    CurrencyCount = l_CurrencyReagents ? l_CurrencyReagents->CurrencyCount : 0;


    // SpellShapeshiftEntry
    SpellShapeshiftEntry const* _shapeshift = GetSpellShapeshift();
    Stances = _shapeshift ? MAKE_PAIR64(_shapeshift->ShapeshiftMask[0], _shapeshift->ShapeshiftMask[1]) : 0;
    StancesNot = _shapeshift ? MAKE_PAIR64(_shapeshift->ShapeshiftExclude[0], _shapeshift->ShapeshiftExclude[1]) : 0;

    // SpellTargetRestrictionsEntry
    SpellTargetRestrictionsEntry const* _target = GetSpellTargetRestrictions();
    Targets = _target ? _target->Targets : 0;
    TargetCreatureType = _target ? _target->TargetCreatureType : 0;
    MaxAffectedTargets = _target ? _target->MaxAffectedTargets : 0;

    // SpellTotemsEntry
    SpellTotemsEntry const* _totem = GetSpellTotems();
    for (uint8 i = 0; i < 2; ++i)
        TotemCategory[i] = _totem ? _totem->TotemCategory[i] : 0;
    for (uint8 i = 0; i < 2; ++i)
        Totem[i] = _totem ? _totem->Totem[i] : 0;

    // SpecializationSpellsEntry
    SpecializationSpellEntry const* specializationInfo = nullptr;
    for (uint32 i = 0; i < sSpecializationSpellStore.GetNumRows(); i++)
    {
        specializationInfo = sSpecializationSpellStore.LookupEntry(i);
        if (!specializationInfo)
            continue;

        if (specializationInfo->LearnSpell == Id)
            SpecializationIdList.push_back(specializationInfo->SpecializationEntry);

        if (specializationInfo->OverrideSpell == Id)
            OverrideSpellList.push_back(specializationInfo->LearnSpell);
    }

    m_TalentIDs.clear();

    ExplicitTargetMask = _GetExplicitTargetMask();
    ChainEntry = NULL;

    ResearchProject =  p_SpellEntry->ResearchProject;

    FirstSpellXSpellVisualID = 0;

    DifficultyEntry const* l_DiffEntry = sDifficultyStore.LookupEntry(DifficultyID);
    while (l_DiffEntry)
    {
        auto l_Iter = p_Visuals.find(DifficultyID);
        if (l_Iter != p_Visuals.end())
        {
            for (SpellXSpellVisualEntry const* l_Visual : l_Iter->second)
            {
                if (!l_Visual->ConditionID)
                {
                    FirstSpellXSpellVisualID = l_Visual->Id;

                    SpellVisual[0] = l_Visual->VisualID[0];
                    SpellVisual[1] = l_Visual->VisualID[1];
                    break;
                }
            }
        }

        /// Stop looping if visual found
        if (FirstSpellXSpellVisualID)
            break;

        l_DiffEntry = sDifficultyStore.LookupEntry(l_DiffEntry->FallbackDifficultyID);
    }

    if (!FirstSpellXSpellVisualID)
    {
        auto l_Iter = p_Visuals.find(Difficulty::DifficultyNone);
        if (l_Iter != p_Visuals.end())
        {
            for (SpellXSpellVisualEntry const* l_Visual : l_Iter->second)
            {
                if (!l_Visual->ConditionID)
                {
                    FirstSpellXSpellVisualID = l_Visual->Id;

                    SpellVisual[0] = l_Visual->VisualID[0];
                    SpellVisual[1] = l_Visual->VisualID[1];
                    break;
                }
            }
        }
    }
}

SpellInfo::~SpellInfo()
{
    _UnloadImplicitTargetConditionLists();
}

uint32 SpellInfo::GetCategory() const
{
    return CategoryEntry ? CategoryEntry->Id : 0;
}

bool SpellInfo::HasEffect(SpellEffects effect) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect(effect))
            return true;

    return false;
}

SpellEffectInfo const* SpellInfo::GetEffectByType(SpellEffects p_Effect) const
{
    for (uint8 l_I = 0; l_I < EffectCount; ++l_I)
        if (Effects[l_I].IsEffect(p_Effect))
            return &Effects[l_I];

    return nullptr;
}

int8 SpellInfo::GetEffectIndex(SpellEffects effect) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect(effect))
            return i;

    return -1;
}

bool SpellInfo::HasAura(AuraType aura) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsAura(aura))
            return true;

    return false;
}

bool SpellInfo::HasAuraPositive(AuraType aura) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsAura(aura) && IsPositiveEffect(i))
            return true;
    }
   
    return false;
}

bool SpellInfo::HasAreaAuraEffect() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsAreaAuraEffect())
            return true;

    return false;
}

bool SpellInfo::HasPersistenAura() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsPersistenAura())
            return true;

    return false;
}

bool SpellInfo::IsExplicitDiscovery() const
{
    return ((Effects[0].Effect == SPELL_EFFECT_CREATE_RANDOM_ITEM
        || Effects[0].Effect == SPELL_EFFECT_CREATE_ITEM_2)
        && Effects[1].Effect == SPELL_EFFECT_SCRIPT_EFFECT)
        || Id == 64323 || Id == 112996 || Id == 101805;
}

bool SpellInfo::IsLootCrafting() const
{
    return HasEffect(SPELL_EFFECT_CREATE_RANDOM_ITEM) ||
    HasEffect(SPELL_EFFECT_CREATE_ITEM) ||
    HasEffect(SPELL_EFFECT_CREATE_ITEM_2);
}

bool SpellInfo::IsQuestTame() const
{
    return Effects[0].Effect == SPELL_EFFECT_THREAT && Effects[1].Effect == SPELL_EFFECT_APPLY_AURA && Effects[1].ApplyAuraName == SPELL_AURA_DUMMY;
}

bool SpellInfo::IsProfessionOrRiding() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsProfessionOrRidingSkill(skill))
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsProfession() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsProfessionSkill(skill))
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPrimaryProfession() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsPrimaryProfessionSkill(skill))
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPrimaryProfessionFirstRank() const
{
    return IsPrimaryProfession() && GetRank() == 1;
}

bool SpellInfo::IsAbilityLearnedWithProfession() const
{
    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(Id);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        SkillLineAbilityEntry const* pAbility = _spell_idx->second;
        if (!pAbility || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
            continue;

        if (pAbility->req_skill_value > 0)
            return true;
    }

    return false;
}

bool SpellInfo::IsAbilityOfSkillType(uint32 skillType) const
{
    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(Id);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
        if (_spell_idx->second->skillId == skillType)
            return true;

    return false;
}

bool SpellInfo::IsAffectingArea() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect() && (Effects[i].IsTargetingArea() || Effects[i].IsEffect(SPELL_EFFECT_PERSISTENT_AREA_AURA) || Effects[i].IsAreaAuraEffect()))
            return true;

    return false;
}

// checks if spell targets are selected from area, doesn't include spell effects in check (like area wide auras for example)
bool SpellInfo::IsTargetingArea() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect() && Effects[i].IsTargetingArea())
            return true;

    return false;
}

bool SpellInfo::NeedsExplicitUnitTarget() const
{
    return GetExplicitTargetMask() & TARGET_FLAG_UNIT_MASK;
}

bool SpellInfo::NeedsToBeTriggeredByCaster() const
{
    if (NeedsExplicitUnitTarget())
        return true;
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsEffect())
        {
            if (Effects[i].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_CHANNEL
                || Effects[i].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_CHANNEL)
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPassive() const
{
    return Attributes & SPELL_ATTR0_PASSIVE;
}

bool SpellInfo::IsRaidMarker() const
{
    return AttributesEx8 & SPELL_ATTR8_RAID_MARKER;
}

bool SpellInfo::IsAutocastable() const
{
    if (Attributes & SPELL_ATTR0_PASSIVE)
        return false;
    if (AttributesEx & SPELL_ATTR1_UNAUTOCASTABLE_BY_PET)
        return false;
    return true;
}

bool SpellInfo::IsStackableWithRanks() const
{
    if (IsPassive())
        return false;
    if (PowerType != POWER_MANA && PowerType != POWER_HEALTH)
        return false;
    if (IsProfessionOrRiding())
        return false;

    if (IsAbilityLearnedWithProfession())
        return false;

    // All stance spells. if any better way, change it.
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        switch (SpellFamilyName)
        {
            case SPELLFAMILY_PALADIN:
                // Paladin aura Spell
                if (Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
                    return false;
                break;
            case SPELLFAMILY_DRUID:
                // Druid form Spell
                if (Effects[i].Effect == SPELL_EFFECT_APPLY_AURA &&
                    Effects[i].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
                    return false;
                break;
        }
    }
    return true;
}

bool SpellInfo::IsPassiveStackableWithRanks() const
{
    return IsPassive() && !HasEffect(SPELL_EFFECT_APPLY_AURA);
}

bool SpellInfo::IsMultiSlotAura() const
{
    return (IsPassive() || Id == 55849 || Id == 40075 || Id == 44413) && Id != 76856;
}

bool SpellInfo::IsCooldownStartedOnEvent() const
{
    return Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE || (CategoryEntry && (CategoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_STARTS_ON_EVENT));
}

bool SpellInfo::IsDeathPersistent() const
{
    return AttributesEx3 & SPELL_ATTR3_DEATH_PERSISTENT;
}

bool SpellInfo::IsRequiringDeadTarget() const
{
    return AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS;
}

bool SpellInfo::IsAllowingDeadTarget() const
{
    return AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD || Targets & (TARGET_FLAG_CORPSE_ALLY | TARGET_FLAG_CORPSE_ENEMY | TARGET_FLAG_UNIT_DEAD);
}

bool SpellInfo::CanBeUsedInCombat() const
{
    return !(Attributes & SPELL_ATTR0_CANT_USED_IN_COMBAT);
}

bool SpellInfo::IsPositive() const
{
    return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE);
}

bool SpellInfo::IsHealingSpell() const
{
    return (HasEffect(SPELL_EFFECT_HEALTH_LEECH)
        || HasEffect(SPELL_EFFECT_HEAL_MAX_HEALTH)
        || HasEffect(SPELL_EFFECT_HEAL_MECHANICAL)
        || HasEffect(SPELL_EFFECT_HEAL_PCT)
        || HasEffect(SPELL_EFFECT_HEAL_MAX_HEALTH)
        || HasEffect(SPELL_EFFECT_HEAL)
        || HasAuraPositive(SPELL_AURA_OBS_MOD_HEALTH)
        || HasAuraPositive(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_PCT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_DONE)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_DONE_PERCENT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT)
        || HasAuraPositive(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER)
        || HasAuraPositive(SPELL_AURA_MOD_BASE_HEALTH_PCT)
        || HasAuraPositive(SPELL_AURA_PERIODIC_HEAL));
}

bool SpellInfo::IsShieldingSpell() const
{
    return (HasAura(SPELL_AURA_SCHOOL_ABSORB)
        || HasAura(SPELL_AURA_SCHOOL_HEAL_ABSORB));
}

bool SpellInfo::IsPositiveEffect(uint8 effIndex) const
{
    switch (effIndex)
    {
        default:
        case 0:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF0);
        case 1:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF1);
        case 2:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF2);
    }
}

bool SpellInfo::IsChanneled() const
{
    return (AttributesEx & (SPELL_ATTR1_CHANNELED_1 | SPELL_ATTR1_CHANNELED_2));
}

bool SpellInfo::NeedsComboPoints() const
{
    return (AttributesEx & (SPELL_ATTR1_REQ_COMBO_POINTS1 | SPELL_ATTR1_REQ_COMBO_POINTS2));
}

bool SpellInfo::IsRangedWeaponSpell() const
{
    return (SpellFamilyName == SPELLFAMILY_HUNTER && !(SpellFamilyFlags[1] & 0x10000000)) // for 53352, cannot find better way
        || (EquippedItemSubClassMask & ITEM_SUBCLASS_MASK_WEAPON_RANGED);
}

bool SpellInfo::IsAutoRepeatRangedSpell() const
{
    return AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG;
}

bool SpellInfo::CanTriggerPoisonAdditional() const
{
    if (SpellFamilyName == SPELLFAMILY_ROGUE)
    {
        switch (Id)
        {
            case 1766:  // Kick
            case 1943:  // Rupture
            case 703:   // Garrote
                return true;
            default:
                break;
        }
    }
    return false;
}

bool SpellInfo::IsAffectedBySpellMods() const
{
    return !(AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS);
}

bool SpellInfo::IsAffectedBySpellMod(SpellModifier* mod) const
{
    if (mod->op != SPELLMOD_CRIT_DAMAGE_BONUS && !IsAffectedBySpellMods())
        return false;

    SpellInfo const* affectSpell = sSpellMgr->GetSpellInfo(mod->spellId);
    // False if affect_spell == NULL or spellFamily not equal
    if (!affectSpell || affectSpell->SpellFamilyName != SpellFamilyName)
        return false;

    // true
    if (mod->mask & SpellFamilyFlags)
        return true;

    // Elemental Blast is affected by Ancestral Swiftness and Maelstrom Weapon
    if (Id == 117014 && (affectSpell->Id == 16188))
        return true;

    return false;
}

bool SpellInfo::CanPierceImmuneAura(SpellInfo const* aura) const
{
    // these spells pierce all avalible spells (Resurrection Sickness for example)
    if (Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return true;

    // these spells (Cyclone for example) can pierce all...         // ...but not these (Divine shield, Ice block, Cyclone and Banish for example)
    if ((AttributesEx & SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE) && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY || aura->Mechanic == MECHANIC_BANISH || aura->Id == 48707 || aura->Id == 157913))) ///< ...nor Anti-Magic Shell nor Evanesce
        return true;

    return false;
}

bool SpellInfo::CanDispelAura(SpellInfo const* aura) const
{
    // Faerie Fire
    if (aura->SpellIconID == 109)
        return true;

    // Faerie Swarm, Touch of Karma
    if (aura && (aura->Id == 102355 || aura->Id == 125174 || aura->Id == 124280))
        return true;

    // These spells (like Mass Dispel) can dispell all auras
    if (Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return true;

    // These auras (like Divine Shield) can't be dispelled
    if (aura->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return false;

    // These auras (Cyclone for example) are not dispelable
    if (aura->AttributesEx & SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE)
        return false;

    switch (aura->Id)
    {
        case 94528: ///< Flare
            return false;
        default:
            break;
    }

    return true;
}

bool SpellInfo::CanCritDamageClassNone() const
{
    switch (Id)
    {
        case 379:   ///< Shaman - Earth Shield
        case 73685: ///< Shaman - Unleash Elements - Unleash Life

        case 86958: ///< Shaman - Cleansing Waters
        case 86961:

        case 33778: ///< Druid - Lifebloom Final Bloom
        case 22845: ///< Druid - Frenzied Regeneration

        case 64844: ///< Priest - Divine Hymn

        case 85222: ///< Paladin - Light of Dawn

        case 94286: ///< Paladin - Protector of the Innocent proc
        case 94288:
        case 94289:

        case 6262:   ///< Warlock - Healthstone

        case 119611: ///< Monk - Renewing Mist

        case 71607:  ///< Item - Bauble of True Blood 10m
        case 71646:  ///< Item - Bauble of True Blood 25m
        case 109825: ///< Item - Windward Heart heroic
        case 108000: ///< Item - Windward Heart lfr
        case 109822: ///< Item - Windward Heart normal
            return true;
    }
    return false;
}

bool SpellInfo::IsSingleTarget() const
{
    // all other single target spells have if it has AttributesEx5
    if (AttributesEx5 & SPELL_ATTR5_SINGLE_TARGET_SPELL)
        return true;

    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificJudgement:
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsSingleTargetWith(SpellInfo const* spellInfo) const
{
    // TODO - need better check
    // Equal icon and spellfamily
    if (SpellFamilyName == spellInfo->SpellFamilyName &&
        SpellIconID == spellInfo->SpellIconID)
        return true;

    SpellSpecificType spec = GetSpellSpecific();
    // spell with single target specific types
    switch (spec)
    {
        case SpellSpecificType::SpellSpecificJudgement:
        case SpellSpecificType::SpellSpecificMagePolymorph:
            if (spellInfo->GetSpellSpecific() == spec)
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsAuraExclusiveBySpecificWith(SpellInfo const* spellInfo) const
{
    SpellSpecificType spellSpec1 = GetSpellSpecific();
    SpellSpecificType spellSpec2 = spellInfo->GetSpellSpecific();
    switch (spellSpec1)
    {
        case SpellSpecificType::SpellSpecificTracker:
        case SpellSpecificType::SpellSpecificWarlockArmor:
        case SpellSpecificType::SpellSpecificMageArmor:
        case SpellSpecificType::SpellSpecificElementalShield:
        case SpellSpecificType::SpellSpecificMagePolymorph:
        case SpellSpecificType::SpellSpecificPresence:
        case SpellSpecificType::SpellSpecificCharm:
        case SpellSpecificType::SpellSpecificScroll:
        case SpellSpecificType::SpellSpecificWarriorEnrage:
        case SpellSpecificType::SpellSpecificMageArcaneBrillance:
        case SpellSpecificType::SpellSpecificPriestDivineSpirit:
        case SpellSpecificType::SpellSpecificPriestSanctum:
        case SpellSpecificType::SpellSpecificChakra:
        case SpellSpecificType::SpellSpecificExocitMunition:
        case SpellSpecificType::SpellSpecificLoneWolfBuff:
        case SpellSpecificType::SpellSpecificLethalPoison:
        case SpellSpecificType::SpellSpecificNonLethalPoison:
        case SpellSpecificType::SpellSpecificCrowdFavorite:
        case SpellSpecificType::SpellSpecificDisposition:
        case SpellSpecificType::SpellSpecificTowerBuffs:
        case SpellSpecificType::SpellSpecificWeeklyEventBuffs:
            return spellSpec1 == spellSpec2;
        case SpellSpecificType::SpellSpecificFood:
            return spellSpec2 == SpellSpecificType::SpellSpecificFood
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        case SpellSpecificType::SpellSpecificDrink:
            return spellSpec2 == SpellSpecificType::SpellSpecificDrink
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        case SpellSpecificType::SpellSpecificFoodAndDrink:
            return spellSpec2 == SpellSpecificType::SpellSpecificFood
                || spellSpec2 == SpellSpecificType::SpellSpecificDrink
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        default:
            return false;
    }
}

bool SpellInfo::IsAuraExclusiveBySpecificPerCasterWith(SpellInfo const* spellInfo) const
{
    SpellSpecificType spellSpec = GetSpellSpecific();
    switch (spellSpec)
    {
        case SpellSpecificType::SpellSpecificSeal:
        case SpellSpecificType::SpellSpecificHand:
        case SpellSpecificType::SpellSpecificAura:
        case SpellSpecificType::SpellSpecificSting:
        case SpellSpecificType::SpellSpecificCurse:
        case SpellSpecificType::SpellSpecificBane:
        case SpellSpecificType::SpellSpecificAspect:
        case SpellSpecificType::SpellSpecificJudgement:
        case SpellSpecificType::SpellSpecificWarlockCorruption:
            return spellSpec == spellInfo->GetSpellSpecific();
        default:
            return false;
    }
}

SpellCastResult SpellInfo::CheckShapeshift(uint32 p_Shapeshift) const
{
    // talents that learn spells can have stance requirements that need ignore
    // (this requirement only for client-side stance show in talent description)
    if (/*GetTalentSpellCost(Id) > 0 &&*/
        (Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL || Effects[1].Effect == SPELL_EFFECT_LEARN_SPELL || Effects[2].Effect == SPELL_EFFECT_LEARN_SPELL))
        return SPELL_CAST_OK;

    if (HasAttribute(SPELL_ATTR13_ACTIVATES_REQUIRED_SHAPESHIFT))
        return SPELL_CAST_OK;

    uint64 stanceMask = (p_Shapeshift ? UI64LIT(1) << (p_Shapeshift - 1) : 0);

    // can explicitly not be casted in this stance
    if (stanceMask & StancesNot)
        return SPELL_FAILED_NOT_SHAPESHIFT;

    // can explicitly be casted in this stance
    if (stanceMask & Stances)
        return SPELL_CAST_OK;

    bool actAsShifted = false;
    SpellShapeshiftFormEntry const* shapeInfo = NULL;
    if (p_Shapeshift > 0)
    {
        shapeInfo = sSpellShapeshiftFormStore.LookupEntry(p_Shapeshift);
        if (!shapeInfo)
        {
            sLog->outError(LOG_FILTER_SPELLS_AURAS, "GetErrorAtShapeshiftedCast: unknown shapeshift %u", p_Shapeshift);
            return SPELL_CAST_OK;
        }
        actAsShifted = !(shapeInfo->m_Flags & 1);            // shapeshift acts as normal form for spells
    }

    if (actAsShifted)
    {
        if (Attributes & SPELL_ATTR0_NOT_SHAPESHIFT) // not while shapeshifted
            return SPELL_FAILED_NOT_SHAPESHIFT;
        else if (Stances != 0)                   // needs other shapeshift
            return SPELL_FAILED_ONLY_SHAPESHIFT;
    }
    else
    {
        // needs shapeshift
        if (!(AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT) && Stances != 0)
            return SPELL_FAILED_ONLY_SHAPESHIFT;
    }

    // Check if stance disables cast of not-stance spells
    // Example: cannot cast any other spells in zombie or ghoul form
    // TODO: Find a way to disable use of these spells clientside
    if (shapeInfo && shapeInfo->m_Flags & 0x400)
    {
        if (!(stanceMask & Stances))
            return SPELL_FAILED_ONLY_SHAPESHIFT;
    }

    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player) const
{
    // normal case
    if (AreaGroupId > 0)
    {
        bool l_Found = false;
        std::vector<uint32> l_AreaGroups = GetAreasForGroup(AreaGroupId);
        for (uint32 areaId : l_AreaGroups)
        {
            if (areaId == zone_id || areaId == area_id)
            {
                l_Found = true;
                break;
            }
        }

        if (!l_Found)
            return SPELL_FAILED_INCORRECT_AREA;
    }

    // continent limitation (virtual continent)
    if (AttributesEx4 & SPELL_ATTR4_CAST_ONLY_IN_OUTLAND)
    {
        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
        MapEntry const* mapEntry = sMapStore.LookupEntry(v_map);
        if (!mapEntry || mapEntry->ExpansionID < 1 || !mapEntry->IsContinent())
            return SPELL_FAILED_INCORRECT_AREA;
    }

    // raid instance limitation
    if (AttributesEx6 & SPELL_ATTR6_NOT_IN_RAID_INSTANCE)
    {
        MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
        if (!mapEntry || mapEntry->IsRaid())
            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
    }

    // DB base check (if non empty then must fit at least single for allow)
    SpellAreaMapBounds saBounds = sSpellMgr->GetSpellAreaMapBounds(Id);
    if (saBounds.first != saBounds.second)
    {
        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (itr->second.IsFitToRequirements(player, zone_id, area_id))
                return SPELL_CAST_OK;
        }
        return SPELL_FAILED_INCORRECT_AREA;
    }

    // spell checks
    switch (Id)
    {
        case 105896:
        case 105900:
        case 105903:
        case 105984:
        case 106224:
        case 106226:
        case 106227:
        case 106080:
        case 106108:
        case 105925:
        case 110070:
        case 110069:
        case 110068:
        case 109075:
        case 110080:
        case 110079:
        case 110078:
        case 106498:
        case 106368:
        case 133755:
        case 140013:
            if (!player)
                return SPELL_CAST_OK;
            return (area_id == 5928 || area_id == 6622) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 103755: // Twilight Epiphany, Archbishop Benedictus, Hour of Twilight
            return ((map_id == 940 && area_id == 5845) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA);
        case 105009: // Gift of Sargeras, Well of Eternity
            return (map_id == 939)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 100713: // Deluge, Ragnaros, Firelands
        case 101015:
        case 101110: // Rage of Ragnaros, Ragnaros, Firelands
            return (area_id == 5770)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 98226: // Balance Bar, Lord Rhyolith, Firelands
            return (area_id == 5763)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 102668: // Sands of the Hourglass, Murozond, End Time
            return (area_id == 5795)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 98229: // Concentration, Majordomo Staghelm, Firelands
        case 98245:
        case 98252:
        case 98253:
        case 98254:
            return (area_id == 5769)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99252: // Blaze of Glory, Baleroc
            return (area_id == 5767)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99837: // Crystal Prison, Shannox
            return (map_id == 720)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 45614: // Shroud of the Scourge
            return (area_id == 4125)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 43820: // Charm of the Witch Doctor
        case 43822: // Charm of the Raging Defender
        case 43816: // Charm of the Bloodletter
        case 43818: // Charm of Mighty Mojo
            return map_id == 568? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99659:
        case 62857:
        case 107926:
            return ((player && player->InBattleground()) ? SPELL_FAILED_NOT_IN_BATTLEGROUND : SPELL_CAST_OK);
        case 29534:                                         // Traces of Silithyst
            return zone_id == 1377 ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 23333:                                         // Warsong Flag
        case 23335:                                         // Silverwing Flag
            return (map_id == 489 || map_id == 726) && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 34976:                                         // Netherstorm Flag
            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 2584:                                          // Waiting to Resurrect
        case 22011:                                         // Spirit Heal Channel
        case 22012:                                         // Spirit Heal
        case 24171:                                         // Resurrection Impact Visual
        case 42792:                                         // Recently Dropped Flag
        case 43681:                                         // Inactive
        case 44535:                                         // Spirit Heal (mana)
        {
            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            return map_id == 1191 || zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 44521:                                         // Preparation
        {
            if (!player)
                return SPELL_FAILED_REQUIRES_AREA;

            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            if (!mapEntry->IsBattleground())
                return SPELL_FAILED_REQUIRES_AREA;

            Battleground* bg = player->GetBattleground();
            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 32724:                                         // Gold Team (Alliance)
        case 32725:                                         // Green Team (Alliance)
        case 35774:                                         // Gold Team (Horde)
        case 35775:                                         // Green Team (Horde)
        {
            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 32727:                                         // Arena Preparation
        {
            if (!player)
                return SPELL_FAILED_REQUIRES_AREA;

            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            if (!mapEntry->IsBattleArena())
                return SPELL_FAILED_REQUIRES_AREA;

            Battleground* bg = player->GetBattleground();
            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 161862:///< Ascension
        {
            if (!player)
                return SPELL_FAILED_DONT_REPORT;

            return map_id == 1116 ? SPELL_CAST_OK : SPELL_FAILED_INCORRECT_AREA;
        }
    }

    // aura limitations
    if (player)
    {
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (!Effects[i].IsAura())
                continue;

            switch (Effects[i].ApplyAuraName)
            {
                case SPELL_AURA_FLY:
                case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
                {
                    if (!player->IsKnowHowFlyIn(map_id, zone_id, Id))
                        return SPELL_FAILED_INCORRECT_AREA;
                    break;
                }
                case SPELL_AURA_MOUNTED:
                {
                    if (Effects[i].MiscValueB && !player->GetMountCapability(Effects[i].MiscValueB))
                        return SPELL_FAILED_NOT_HERE;
                    break;
                }
            }
        }
    }

    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckTarget(Unit const* caster, WorldObject const* target, bool implicit) const
{
    if (AttributesEx & SPELL_ATTR1_CANT_TARGET_SELF && caster == target)
        return SPELL_FAILED_BAD_TARGETS;

    // check visibility - ignore stealth for implicit (area) targets
    if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE) && (!caster->canSeeOrDetect(target, implicit)))
        return SPELL_FAILED_BAD_TARGETS;

    Unit const* unitTarget = target->ToUnit();

    // Custom MoP Script - Hack fix for Piercing Howl, Multi-Shot, Psychic Terror, Earthgrab Totem - it doesn't break stealth.
    if ((Id == 12323 || Id == 2643 || Id == 113792 || Id == 3600 || Id == 64695) && (unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) || HasAura(SPELL_AURA_MOD_INVISIBILITY)) && unitTarget)
        return SPELL_FAILED_BAD_TARGETS;

    // Custom MoP Script - Hack fix for Vanish immunity, players with 3 sec immunity can't be broken from the stealth
    if (unitTarget && !unitTarget->IsFriendlyTo(caster) && unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) && unitTarget->HasAura(131361))
        return SPELL_FAILED_BAD_TARGETS;

    // creature/player specific target checks
    if (unitTarget)
    {
        if (AttributesEx & SPELL_ATTR1_CANT_TARGET_IN_COMBAT && unitTarget->isInCombat())
            return SPELL_FAILED_TARGET_AFFECTING_COMBAT;

        // only spells with SPELL_ATTR3_ONLY_TARGET_GHOSTS can target ghosts
        if (((AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS) != 0) != unitTarget->HasAuraType(SPELL_AURA_GHOST))
        {
            if (AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS)
                return SPELL_FAILED_TARGET_NOT_GHOST;
            else
                return SPELL_FAILED_BAD_TARGETS;
        }

        if (caster != unitTarget)
        {
            if (caster->IsPlayer())
            {
                // Do not allow these spells to target creatures not tapped by us (Banish, Polymorph, many quest spells)
                if (AttributesEx2 & SPELL_ATTR2_CANT_TARGET_TAPPED)
                    if (Creature const* targetCreature = unitTarget->ToCreature())
                        if (targetCreature->hasLootRecipient() && !targetCreature->isTappedBy(caster->ToPlayer()))
                            return SPELL_FAILED_CANT_CAST_ON_TAPPED;

                if (AttributesCu & SPELL_ATTR0_CU_PICKPOCKET)
                {
                     if (unitTarget->IsPlayer())
                         return SPELL_FAILED_BAD_TARGETS;
                     else if ((unitTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) == 0)
                         return SPELL_FAILED_TARGET_NO_POCKETS;
                }

                // Not allow disarm unarmed player
                if (Mechanic == MECHANIC_DISARM)
                {
                    if (unitTarget->IsPlayer())
                    {
                        Player const* player = unitTarget->ToPlayer();
                        if (!player->GetWeaponForAttack(WeaponAttackType::BaseAttack) || !player->IsUseEquipedWeapon(true))
                            return SPELL_FAILED_TARGET_NO_WEAPONS;
                    }
                    else if (!unitTarget->GetUInt32Value(UNIT_FIELD_VIRTUAL_ITEMS) && Id != 64058) // Custom MoP Script - Hack Fix Psychic Horror
                        return SPELL_FAILED_TARGET_NO_WEAPONS;
                }
            }
        }
    }
    // corpse specific target checks
    else if (Corpse const* corpseTarget = target->ToCorpse())
    {
        // cannot target bare bones
        if (corpseTarget->GetType() == CORPSE_BONES)
            return SPELL_FAILED_BAD_TARGETS;
        // we have to use owner for some checks (aura preventing resurrection for example)
        if (Player* owner = ObjectAccessor::FindPlayer(corpseTarget->GetOwnerGUID()))
            unitTarget = owner;
        // we're not interested in corpses without owner
        else
            return SPELL_FAILED_BAD_TARGETS;
    }
    // other types of objects - always valid
    else return SPELL_CAST_OK;

    // corpseOwner and unit specific target checks
    if (AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_PLAYERS && !unitTarget->ToPlayer())
       return SPELL_FAILED_TARGET_NOT_PLAYER;

    if (!IsAllowingDeadTarget() && !unitTarget->isAlive())
       return SPELL_FAILED_TARGETS_DEAD;

    // check this flag only for implicit targets (chain and area), allow to explicitly target units for spells like Shield of Righteousness
    if (implicit && AttributesEx6 & SPELL_ATTR6_CANT_TARGET_CROWD_CONTROLLED && !unitTarget->CanFreeMove())
       return SPELL_FAILED_BAD_TARGETS;

    // checked in Unit::IsValidAttack/AssistTarget, shouldn't be checked for ENTRY targets
    //if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
    //    return SPELL_FAILED_BAD_TARGETS;

    //if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS)

    if (!CheckTargetCreatureType(unitTarget))
    {
        if (target->IsPlayer())
            return SPELL_FAILED_TARGET_IS_PLAYER;
        else
            return SPELL_FAILED_BAD_TARGETS;
    }

    // check GM mode and GM invisibility - only for player casts (npc casts are controlled by AI) and negative spells
    if (unitTarget != caster && (caster->IsControlledByPlayer() || !IsPositive()) && unitTarget->IsPlayer())
    {
        if (!unitTarget->ToPlayer()->IsVisible())
            return SPELL_FAILED_BM_OR_INVISGOD;

        if (unitTarget->ToPlayer()->isGameMaster())
            return SPELL_FAILED_BM_OR_INVISGOD;
    }

    // not allow casting on flying player
    if (unitTarget->HasUnitState(UNIT_STATE_IN_FLIGHT) && !(AttributesCu & SPELL_ATTR0_CU_ALLOW_INFLIGHT_TARGET))
        return SPELL_FAILED_BAD_TARGETS;

    // TARGET_UNIT_MASTER gets blocked here for passengers, because the whole idea of this check is to
    // not allow passengers to be implicitly hit by spells, however this target type should be an exception,
    // if this is left it kills spells that award kill credit from vehicle to master and some or all* spells,
    // the use of these 2 covers passenger target check

    if (!(Targets & TARGET_UNIT_MASTER) && !caster->IsVehicle())
    {
        if (TargetAuraState && !unitTarget->HasAuraState(AuraStateType(TargetAuraState), this, caster))
            return SPELL_FAILED_TARGET_AURASTATE;

        if (TargetAuraStateNot && unitTarget->HasAuraState(AuraStateType(TargetAuraStateNot), this, caster))
            return SPELL_FAILED_TARGET_AURASTATE;
    }

    if (TargetAuraSpell && !unitTarget->HasAura(TargetAuraSpell))
        return SPELL_FAILED_TARGET_AURASTATE;

    if (ExcludeTargetAuraSpell && unitTarget->HasAura(ExcludeTargetAuraSpell))
        return SPELL_FAILED_TARGET_AURASTATE;

    if (unitTarget->HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
        if (HasEffect(SPELL_EFFECT_SELF_RESURRECT) || HasEffect(SPELL_EFFECT_RESURRECT) || HasEffect(SPELL_EFFECT_RESURRECT_NEW))
            return SPELL_FAILED_TARGET_CANNOT_BE_RESURRECTED;

    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckExplicitTarget(Unit const* caster, WorldObject const* target, Item const* itemTarget) const
{
    uint32 neededTargets = GetExplicitTargetMask();
    if (!target)
    {
        if (neededTargets & (TARGET_FLAG_UNIT_MASK | TARGET_FLAG_GAMEOBJECT_MASK | TARGET_FLAG_CORPSE_MASK))
            if (!(neededTargets & TARGET_FLAG_GAMEOBJECT_ITEM) || !itemTarget)
                return SPELL_FAILED_BAD_TARGETS;
        return SPELL_CAST_OK;
    }

    if (Unit const* unitTarget = target->ToUnit())
    {
        if (neededTargets & (TARGET_FLAG_UNIT_ENEMY | TARGET_FLAG_UNIT_ALLY | TARGET_FLAG_UNIT_RAID | TARGET_FLAG_UNIT_PARTY | TARGET_FLAG_UNIT_MINIPET | TARGET_FLAG_UNIT_PASSENGER))
        {
            if (neededTargets & TARGET_FLAG_UNIT_ENEMY)
                if (caster->_IsValidAttackTarget(unitTarget, this))
                    return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_ALLY
                || (neededTargets & TARGET_FLAG_UNIT_PARTY && caster->IsInPartyWith(unitTarget))
                || (neededTargets & TARGET_FLAG_UNIT_RAID && caster->IsInRaidWith(unitTarget)))
                    if (caster->_IsValidAssistTarget(unitTarget, this))
                        return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_MINIPET)
                if (unitTarget->GetGUID() == caster->GetCritterGUID())
                    return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_PASSENGER)
                if (unitTarget->IsOnVehicle(caster))
                    return SPELL_CAST_OK;
            return SPELL_FAILED_BAD_TARGETS;
        }
    }
    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckVehicle(Unit const* caster) const
{
    // All creatures should be able to cast as passengers freely, restriction and attribute are only for players
    if (caster->GetTypeId() != TYPEID_PLAYER)
        return SPELL_CAST_OK;

    Vehicle* vehicle = caster->GetVehicle();
    if (vehicle)
    {
        uint16 checkMask = 0;
        for (uint8 effIndex = EFFECT_0; effIndex < EffectCount; ++effIndex)
        {
            if (Effects[effIndex].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
            {
                SpellShapeshiftFormEntry const* shapeShiftEntry = sSpellShapeshiftFormStore.LookupEntry(Effects[effIndex].MiscValue);
                if (shapeShiftEntry && (shapeShiftEntry->m_Flags & 1) == 0)  // unk flag
                    checkMask |= VEHICLE_SEAT_FLAG_UNCONTROLLED;
                break;
            }
        }

        if (HasAura(SPELL_AURA_MOUNTED))
            checkMask |= VEHICLE_SEAT_FLAG_CAN_CAST_MOUNT_SPELL;

        if (!checkMask)
            checkMask = VEHICLE_SEAT_FLAG_CAN_ATTACK;

        VehicleSeatEntry const* vehicleSeat = vehicle->GetSeatForPassenger(caster);
        if (!(AttributesEx6 & SPELL_ATTR6_CASTABLE_WHILE_ON_VEHICLE) && !(Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED)
            && (vehicleSeat->m_flags & checkMask) != checkMask)
            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;

        // Can only summon uncontrolled minions/guardians when on controlled vehicle
        if (vehicleSeat->m_flags & (VEHICLE_SEAT_FLAG_CAN_CONTROL | VEHICLE_SEAT_FLAG_UNK2))
        {
            for (uint8 i = EFFECT_0; i < EffectCount; ++i)
            {
                if (Effects[i].Effect != SPELL_EFFECT_SUMMON)
                    continue;

                SummonPropertiesEntry const* props = sSummonPropertiesStore.LookupEntry(Effects[i].MiscValueB);
                if (props && props->Category != SUMMON_CATEGORY_WILD)
                    return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
            }
        }
    }

    return SPELL_CAST_OK;
}

bool SpellInfo::CheckTargetCreatureType(Unit const* target) const
{
    // Curse of Doom & Exorcism: not find another way to fix spell target check :/
    if (SpellFamilyName == SPELLFAMILY_WARLOCK && GetCategory() == 1179)
    {
        // not allow cast at player
        if (target->IsPlayer())
            return false;
        else
            return true;
    }

    uint32 creatureType = target->GetCreatureTypeMask();
    return !TargetCreatureType || !creatureType || (creatureType & TargetCreatureType);
}

SpellSchoolMask SpellInfo::GetSchoolMask() const
{
    return SpellSchoolMask(SchoolMask);
}

uint32 SpellInfo::GetAllEffectsMechanicMask() const
{
    uint32 mask = 0;
    if (Mechanic)
        mask |= 1 << Mechanic;
    for (int i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect() && Effects[i].Mechanic)
            mask |= 1 << Effects[i].Mechanic;

    return mask;
}

uint32 SpellInfo::GetEffectMechanicMask(uint8 effIndex) const
{
    uint32 mask = 0;
    if (Mechanic)
        mask |= 1<< Mechanic;
    if (Effects[effIndex].IsEffect() && Effects[effIndex].Mechanic)
        mask |= 1<< Effects[effIndex].Mechanic;
    return mask;
}

uint32 SpellInfo::GetSpellMechanicMaskByEffectMask(uint32 effectMask) const
{
    uint32 mask = 0;
    if (Mechanic)
        mask |= 1<< Mechanic;
    for (int i = 0; i < EffectCount; ++i)
        if ((effectMask & (1 << i)) && Effects[i].Mechanic)
            mask |= 1<< Effects[i].Mechanic;

    return mask;
}

Mechanics SpellInfo::GetEffectMechanic(uint8 effIndex) const
{
    if (Effects[effIndex].IsEffect() && Effects[effIndex].Mechanic)
        return Mechanics(Effects[effIndex].Mechanic);
    if (Mechanic)
        return Mechanics(Mechanic);
    return MECHANIC_NONE;
}

bool SpellInfo::HasAnyEffectMechanic() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].Mechanic)
            return true;

    return false;
}

uint32 SpellInfo::GetDispelMask() const
{
    return GetDispelMask(DispelType(Dispel));
}

uint32 SpellInfo::GetDispelMask(DispelType type)
{
    // If dispel all
    if (type == DISPEL_ALL)
        return DISPEL_ALL_MASK;
    else
        return uint32(1 << type);
}

uint32 SpellInfo::GetExplicitTargetMask() const
{
    return ExplicitTargetMask;
}

AuraStateType SpellInfo::GetAuraState() const
{
    // Seals
    if (GetSpellSpecific() == SpellSpecificType::SpellSpecificSeal)
        return AURA_STATE_JUDGEMENT;

    // Conflagrate aura state on Immolate and Shadowflame
    if (SpellFamilyName == SPELLFAMILY_WARLOCK &&
        // Immolate
        ((SpellFamilyFlags[0] & 4) ||
        // Shadowflame
        (SpellFamilyFlags[2] & 2)))
        return AURA_STATE_CONFLAGRATE;

    // Faerie Fire (druid versions)
    if (Id == 770 || Id == 102355)
        return AURA_STATE_FAERIE_FIRE;

    // Sting (hunter's pet ability)
    if (GetCategory() == 1133)
        return AURA_STATE_FAERIE_FIRE;

    // Victorious
    if (SpellFamilyName == SPELLFAMILY_WARRIOR &&  SpellFamilyFlags[1] & 0x00040000)
        return AURA_STATE_WARRIOR_VICTORY_RUSH;

    // Swiftmend state on Regrowth & Rejuvenation
    if (SpellFamilyName == SPELLFAMILY_DRUID && SpellFamilyFlags[0] & 0x50)
        return AURA_STATE_SWIFTMEND;

    // Deadly poison aura state
    if (SpellFamilyName == SPELLFAMILY_ROGUE && SpellFamilyFlags[0] & 0x10000)
        return AURA_STATE_DEADLY_POISON;

    // Enrage aura state
    if (Dispel == DISPEL_ENRAGE)
        return AURA_STATE_ENRAGE;

    // Bleeding aura state
    if (GetAllEffectsMechanicMask() & 1<<MECHANIC_BLEED)
        return AURA_STATE_BLEEDING;

    if (GetSchoolMask() & SPELL_SCHOOL_MASK_FROST)
        for (uint8 i = 0; i < EffectCount; ++i)
            if (Effects[i].IsAura() && (Effects[i].ApplyAuraName == SPELL_AURA_MOD_STUN
                || Effects[i].ApplyAuraName == SPELL_AURA_MOD_ROOT
                || Effects[i].ApplyAuraName == SPELL_AURA_MOD_ROOT_2))
                return AURA_STATE_FROZEN;

    switch (Id)
    {
        case 71465: // Divine Surge
        case 50241: // Evasive Charges
            return AURA_STATE_UNKNOWN22;
        default:
            break;
    }

    return AURA_STATE_NONE;
}

SpellSpecificType SpellInfo::GetSpellSpecific() const
{
    switch (SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
        {
            // Food / Drinks (mostly)
            if (AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
            {
                bool food = false;
                bool drink = false;
                for (uint8 i = 0; i < EffectCount; ++i)
                {
                    if (!Effects[i].IsAura())
                        continue;

                    switch (Effects[i].ApplyAuraName)
                    {
                        // Food
                        case SPELL_AURA_MOD_REGEN:
                        case SPELL_AURA_OBS_MOD_HEALTH:
                            food = true;
                            break;
                        // Drink
                        case SPELL_AURA_MOD_POWER_REGEN:
                        case SPELL_AURA_OBS_MOD_POWER:
                            drink = true;
                            break;
                        default:
                            break;
                    }
                }

                if (SpellIconID == 358)
                    food = true;

                if (food && drink)
                    return SpellSpecificType::SpellSpecificFoodAndDrink;
                else if (food)
                    return SpellSpecificType::SpellSpecificFood;
                else if (drink)
                    return SpellSpecificType::SpellSpecificDrink;
            }
            else if ((AttributesEx2 & SPELL_ATTR2_FOOD_BUFF) || SpellIconID == 2560)
                return SpellSpecificType::SpellSpecificWellFed;
            // scrolls effects
            else
            {
                SpellInfo const* firstRankSpellInfo = GetFirstRankSpell();
                switch (firstRankSpellInfo->Id)
                {
                    case 8118: // Strength
                    case 8099: // Stamina
                    case 8112: // Spirit
                    case 8096: // Intellect
                    case 8115: // Agility
                    case 8091: // Armor
                        return SpellSpecificType::SpellSpecificScroll;
                }
            }

            switch (Id)
            {
                case 163366:    ///< Crowd Favorite - 25%
                case 163368:    ///< Crowd Favorite - 50%
                case 163369:    ///< Crowd Favorite - 75%
                case 163370:    ///< Crowd Favorite - 100%
                    return SpellSpecificType::SpellSpecificCrowdFavorite;
                case 157951:    ///< Aggressive Disposition
                case 158016:    ///< Fierce Disposition
                case 158017:    ///< Savage Disposition
                    return SpellSpecificType::SpellSpecificDisposition;
                case 173534:    ///< Hold your ground
                case 173541:    ///< Tower Defense
                case 173549:    ///< Stand Fast
                    return SpellSpecificType::SpellSpecificTowerBuffs;
                case 186400:    ///< Sign of Apexis
                case 186401:    ///< Sign of the Skirmisher
                case 186403:    ///< Sign of Battle
                case 186404:    ///< Sign of the Emissary
                case 186406:    ///< Sign of the Critter
                    return SpellSpecificType::SpellSpecificWeeklyEventBuffs;
                default:
                    break;
            }

            break;
        }
        case SPELLFAMILY_MAGE:
        {
            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
            if (SpellFamilyFlags[0] & 0x12040000)
                return SpellSpecificType::SpellSpecificMageArmor;

            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
            if (SpellFamilyFlags[0] & 0x400)
                return SpellSpecificType::SpellSpecificMageArcaneBrillance;

            if ((SpellFamilyFlags[0] & 0x1000000) && Effects[0].ApplyAuraName == SPELL_AURA_MOD_CONFUSE)
                return SpellSpecificType::SpellSpecificMagePolymorph;

            break;
        }
        case SPELLFAMILY_WARRIOR:
        {
            switch (Id)
            {
                case 12880: // Enrage (Enrage)
                case 57518: // Enrage (Wrecking Crew)
                    return SpellSpecificType::SpellSpecificWarriorEnrage;
                default:
                    break;
            }
            break;
        }
        case SPELLFAMILY_WARLOCK:
        {
            // Agony, Doom (Metamorphosis) and Havoc are no longer curses
            if (Id == 980 || Id == 603 || Id == 80240)
                return SpellSpecificType::SpellSpecificBane;

            // only warlock curses have this
            if (Dispel == DISPEL_CURSE)
                return SpellSpecificType::SpellSpecificCurse;

            // Warlock (Demon Armor | Fel Armor)
            if (SpellFamilyFlags[1] & 0x20000020)
                return SpellSpecificType::SpellSpecificWarlockArmor;

            //seed of corruption and corruption
            if (SpellFamilyFlags[1] & 0x10 || SpellFamilyFlags[0] & 0x2)
                return SpellSpecificType::SpellSpecificWarlockCorruption;

            break;
        }
        case SPELLFAMILY_PRIEST:
        {
            // "Well Fed" buff from Blessed Sunfruit, Blessed Sunfruit Juice, Alterac Spring Water
            if ((Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING) &&
                (InterruptFlags & AURA_INTERRUPT_FLAG_MOVE) &&
                (SpellIconID == 52 || SpellIconID == 79))
                return SpellSpecificType::SpellSpecificWellFed;

            // Divine Spirit and Prayer of Spirit
            if (SpellFamilyFlags[0] & 0x20)
                return SpellSpecificType::SpellSpecificPriestDivineSpirit;

            // Priest (Inner Will | Inner Fire)
            if (Id == 588 || Id == 73413)
                return SpellSpecificType::SpellSpecificPriestSanctum;

            // Priest chakras
            if (Id == 81206 || Id == 81208 || Id == 81209)
                return SpellSpecificType::SpellSpecificChakra;

            break;
        }
        case SPELLFAMILY_HUNTER:
        {
            // only hunter stings have this
            if (Dispel == DISPEL_POISON)
                return SpellSpecificType::SpellSpecificSting;

            // only hunter aspects have this (but not all aspects in hunter family) and Hack fix for Deterrence - Is not an aspect !
            if (SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010) && Id != 67801)
                return SpellSpecificType::SpellSpecificAspect;

            switch (Id)
            {
                case 162536:///< Incendiary Ammo
                case 162537:///< Poisoned Ammo
                case 162539:///< Frozen Ammo
                    return SpellSpecificType::SpellSpecificExocitMunition;
                case 160198:///< Grace of the Cat
                case 160199:///< Fortitude of the Bear
                case 160200:///< Ferocity of the Raptor
                case 160203:///< Haste of the Hyena
                case 160205:///< Wisdom of the Serpent
                case 160206:///< Power of the Primates
                case 172967:///< Versatility of the Ravager
                case 172968:///< Quickness of the Dragonhawk
                    return SpellSpecificType::SpellSpecificLoneWolfBuff;
            }

            break;
        }
        case SPELLFAMILY_PALADIN:
        {
            if (SpellFamilyFlags[0] & 0x01000002)
                return SpellSpecificType::SpellSpecificBlessing;

            // Collection of all the seal family flags. No other paladin spell has any of those.
            // Collection of all the seal Id.
            if (Id == 20164         // Seal of Justice
                || Id == 20154      // Seal of Righteoussness
                || Id == 31801      // Seal of Truth
                || Id == 20165      // Seal of Insight
                || Id == 105361)    // Seal of Command
                return SpellSpecificType::SpellSpecificSeal;

            if (SpellFamilyFlags[0] & 0x00002190)
                return SpellSpecificType::SpellSpecificHand;

            // Judgement, Judgement of Truth, Judgement of Righteoussness, Judgement of Light
            if (Id == 20271 || Id == 31804 || Id == 20187 || Id == 54158)
                return SpellSpecificType::SpellSpecificJudgement;

            // only paladin auras have this (for palaldin class family)
            if (SpellFamilyFlags[2] & 0x00000020)
                return SpellSpecificType::SpellSpecificAura;

            break;
        }
        case SPELLFAMILY_SHAMAN:
        {
            // family flags 10 (Lightning), 42 (Earth), 37 (Water), proc shield from T2 8 pieces bonus
            if (SpellFamilyFlags[1] & 0x420
                || SpellFamilyFlags[0] & 0x00000400
                || Id == 23552)
                return SpellSpecificType::SpellSpecificElementalShield;

            break;
        }
        case SPELLFAMILY_DEATHKNIGHT:
            /// Blood Presence, Unholy Presence, Frost Presence
            if (Id == 48263 || Id == 48265 || Id == 48266)
                return SpellSpecificType::SpellSpecificPresence;
            break;
        case SPELLFAMILY_ROGUE:
        {
            switch (Id)
            {
                case 3408:    ///< Crippling Poison
                case 108211:  ///< Leeching Poison
                    return SpellSpecificType::SpellSpecificLethalPoison;
                case 2823:    ///< Deadly Poison
                case 8679:    ///< Wound Poison
                case 157584:  ///< Swift Poison
                    return SpellSpecificType::SpellSpecificNonLethalPoison;
                default:
                    break;
            }

            break;
        }
    }

    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_APPLY_AURA || Effects[i].Effect == SPELL_EFFECT_APPLY_AURA_ON_PET)
        {
            switch (Effects[i].ApplyAuraName)
            {
                case SPELL_AURA_MOD_CHARM:
                case SPELL_AURA_MOD_POSSESS_PET:
                case SPELL_AURA_MOD_POSSESS:
                case SPELL_AURA_AOE_CHARM:
                    return SpellSpecificType::SpellSpecificCharm;
                case SPELL_AURA_TRACK_CREATURES:
                case SPELL_AURA_TRACK_RESOURCES:
                case SPELL_AURA_TRACK_STEALTHED:
                    return SpellSpecificType::SpellSpecificTracker;
            }
        }
    }

    return SpellSpecificType::SpellSpecificNormal;
}

float SpellInfo::GetMinRange(bool positive) const
{
    if (!RangeEntry)
        return 0.0f;
    if (positive)
        return RangeEntry->minRangeFriend;
    return RangeEntry->minRangeHostile;
}

float SpellInfo::GetMaxRange(bool positive, Unit* caster, Spell* spell) const
{
    if (!RangeEntry)
        return 0.0f;
    float range;
    if (positive)
        range = RangeEntry->maxRangeFriend;
    else
        range = RangeEntry->maxRangeHostile;
    if (caster)
        if (Player* modOwner = caster->GetSpellModOwner())
            modOwner->ApplySpellMod(Id, SPELLMOD_RANGE, range, spell);
    return range;
}

int32 SpellInfo::GetDuration() const
{
    if (!DurationEntry)
        return 0;
    return (DurationEntry->Duration[0] == -1) ? -1 : abs(DurationEntry->Duration[0]);
}

int32 SpellInfo::GetMaxDuration() const
{
    if (!DurationEntry)
        return 0;
    return (DurationEntry->Duration[2] == -1) ? -1 : abs(DurationEntry->Duration[2]);
}

uint32 SpellInfo::CalcCastTime(Unit* p_Caster, Spell* p_Spell) const
{
    int32 l_CastTime = 0;

    // not all spells have cast time index and this is all is pasiive abilities
    if (p_Caster && CastTimeMax > 0)
    {
        l_CastTime = CastTimeMax;
        if (CastTimeMaxLevel > int32(p_Caster->getLevel()))
            l_CastTime = CastTimeMin + int32(p_Caster->getLevel() - 1) * (CastTimeMax - CastTimeMin) / (CastTimeMaxLevel - 1);
    }
    else if (CastTimeEntry)
        l_CastTime = CastTimeEntry->CastTime;

    if (!l_CastTime)
        return 0;

    /// Swift Riding Crop
    if (p_Caster && p_Caster->HasAura(170495))
    {
        if (SpellCategoriesEntry const* l_Cat = GetSpellCategories())
        {
            if (l_Cat->Mechanic == MECHANIC_MOUNT) ///< Mount
                return 0;
        }
    }

    if (p_Caster)
        p_Caster->ModSpellCastTime(this, l_CastTime, p_Spell);

    /// Glyph of Capacitor Totem
    if (p_Caster && Id == 118905)
    {
        if (Unit* l_Owner = p_Caster->GetOwner())
        {
            if (l_Owner->HasAura(55442))
                l_CastTime -= 2000;
        }
    }

    /// Glyph of the Righteous Retreat
    if (p_Caster && Id == 8690)
    {
        if (p_Caster->HasAura(115933) && (p_Caster->HasAura(642)))
            l_CastTime /= 2;
    }

    /// Glyph of Demon Training with Imp
    if (p_Caster && p_Caster->GetEntry() == 416 && p_Caster->GetOwner() && p_Caster->GetOwner()->HasAura(56249) && Id == 3110)
        l_CastTime /= 2;

    /// Flayer
    if (HasEffect(SPELL_EFFECT_SKINNING) && p_Caster->HasAura(68978))
        l_CastTime = CalculatePct(l_CastTime, 66);

    /// Cultivation
    if (HasEffect(SPELL_EFFECT_SKILL) && p_Caster->HasAura(20552) && AttributesEx10 & SPELL_ATTR10_HERB_GATHERING_MINING)
    {
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (Effects[i].Effect == SPELL_EFFECT_SKILL && Effects[i].MiscValue == SKILL_HERBALISM)
            {
                l_CastTime = CalculatePct(l_CastTime, 66);
                break;
            }
        }
    }

    /// Loot bonus animation
    if (HasEffect(SpellEffects::SPELL_EFFECT_LOOT_BONUS))
        l_CastTime = 0;

    /// Elegon - Overloaded
    if (p_Caster && p_Caster->HasAura(117204))
    {
        if (Aura* overloaded = p_Caster->GetAura(117204))
            l_CastTime -= CalculatePct(l_CastTime, (20 * overloaded->GetStackAmount()));
    }

    if (p_Caster && p_Caster->GetTypeId() == TypeID::TYPEID_UNIT)
    {
        if (p_Caster->ToCreature()->IsAIEnabled)
            p_Caster->ToCreature()->AI()->OnCalculateCastingTime(this, l_CastTime);
    }

    return (l_CastTime > 0) ? uint32(l_CastTime) : 0;
}

uint32 SpellInfo::GetMaxTicks() const
{
    int32 DotDuration = GetDuration();
    if (DotDuration == 0)
        return 1;

    // 200% limit
    if (DotDuration > 30000)
        DotDuration = 30000;

    for (uint8 x = 0; x < EffectCount; x++)
    {
        if (Effects[x].Effect == SPELL_EFFECT_APPLY_AURA
            || Effects[x].Effect == SPELL_EFFECT_APPLY_AURA_ON_PET)
            switch (Effects[x].ApplyAuraName)
            {
                case SPELL_AURA_PERIODIC_DAMAGE:
                case SPELL_AURA_PERIODIC_HEAL:
                case SPELL_AURA_PERIODIC_LEECH:
                    if (Effects[x].Amplitude != 0)
                        return DotDuration / Effects[x].Amplitude;
                    break;
            }
    }

    return 6;
}

uint32 SpellInfo::GetRecoveryTime() const
{
    return RecoveryTime > CategoryRecoveryTime ? RecoveryTime : CategoryRecoveryTime;
}

void SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask, int32* m_powerCost) const
{
    if (SpellPowers.empty())
        return;

    // Spell drain all exist power on cast (Only paladin lay of Hands)
    if (AttributesEx & SPELL_ATTR1_DRAIN_ALL_POWER)
    {
        for (auto itr : SpellPowers)
        {
            Powers PowerType = Powers(itr->PowerType);

            if (PowerType == POWER_HEALTH) // If power type - health drain all
                m_powerCost[POWER_TO_INDEX(PowerType)] = int32(caster->GetHealth());
            else if (PowerType < MAX_POWERS) // Else drain all power
                m_powerCost[POWER_TO_INDEX(PowerType)] = caster->GetPower(Powers(PowerType));
            else
                sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
        }
    }

    int32 powerCost = 0;
    for (auto itr : SpellPowers)
    {
        if (itr->RequiredAuraSpellId && !caster->HasAura(itr->RequiredAuraSpellId))
            continue;

        Powers PowerType = Powers(itr->PowerType);

        // Base powerCost
        powerCost = itr->Cost;

        // PCT cost from total amount
        if (itr->CostBasePercentage)
        {
            switch (PowerType)
            {
                // health as power used
                case POWER_HEALTH:
                    powerCost += int32(CalculatePct(caster->GetMaxHealth(), itr->CostBasePercentage));
                    break;
                case POWER_MANA:
                    powerCost += int32(CalculatePct(caster->GetCreateMana(), itr->CostBasePercentage));
                    break;
                case POWER_RAGE:
                case POWER_FOCUS:
                case POWER_ENERGY:
                case POWER_CHI:
                    powerCost += int32(CalculatePct(caster->GetMaxPower(Powers(PowerType)), itr->CostBasePercentage));
                    break;
                case POWER_RUNES:
                case POWER_RUNIC_POWER:
                    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "CalculateManaCost: Not implemented yet!");
                    break;
                default:
                    sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
                    break;
            }
        }

        // PCT cost from max amount
        if (itr->CostMaxPercentage)
        {
            switch (PowerType)
            {
                // health as power used
                case POWER_HEALTH:
                    powerCost += int32(CalculatePct(caster->GetMaxHealth(), itr->CostMaxPercentage));
                    break;
                case POWER_MANA:
                case POWER_RAGE:
                case POWER_FOCUS:
                case POWER_ENERGY:
                case POWER_CHI:
                    powerCost += int32(CalculatePct(caster->GetMaxPower(PowerType), itr->CostMaxPercentage));
                    break;
                case POWER_RUNES:
                case POWER_RUNIC_POWER:
                    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "CalculateManaCost: Not implemented yet!");
                    break;
                default:
                    sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
                    break;
            }
        }

        // Flat mod from caster auras by spell school and power type
        Unit::AuraEffectList const& auras = caster->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_COST_SCHOOL);
        for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
        {
            if (!((*i)->GetMiscValue() & schoolMask))
                continue;

            if (!((*i)->GetMiscValueB() & (1 << PowerType)))
                continue;

            powerCost += (*i)->GetAmount();
        }

        // Apply cost mod by spell
        if (Player* modOwner = caster->GetSpellModOwner())
            modOwner->ApplySpellMod(Id, SPELLMOD_COST, powerCost);

        // PCT mod from user auras by spell school and power type
        Unit::AuraEffectList const& aurasPct = caster->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT);
        for (Unit::AuraEffectList::const_iterator i = aurasPct.begin(); i != aurasPct.end(); ++i)
        {
            if (!((*i)->GetMiscValue() & schoolMask))
                continue;

            if (!((*i)->GetMiscValueB() & (1 << PowerType)))
                continue;

            powerCost += CalculatePct(powerCost, (*i)->GetAmount());
        }

        /// Hack fix: Soul Swap Exhale shouldn't take any mana
        if (Id == 86213 && PowerType == POWER_MANA)
            powerCost = 0;

        /// Hack fix: Wild Strike shouldn't take rage if warrior has Bloodsurge
        if (PowerType == POWER_RAGE && Id == 100130 && caster->HasAura(46916))
            powerCost = 0;

        /// Hack fix: Drain Life shouldn't take mana if warlock is on Metamorphis form
        if (PowerType == POWER_MANA && Id == 689 && caster->HasAura(103958))
            powerCost = 0;

        m_powerCost[POWER_TO_INDEX(PowerType)] += powerCost;
    }
}

inline float CalcPPMHasteMod(SpellProcsPerMinuteModEntry const* mod, Unit* caster)
{
    float haste = caster->GetFloatValue(UNIT_FIELD_MOD_HASTE);
    float rangedHaste = caster->GetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE);
    float spellHaste = caster->GetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE);
    float regenHaste = caster->GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);

    switch (mod->Param)
    {
        case 1:
            return (1.0f / haste - 1.0f) * mod->Coeff;
        case 2:
            return (1.0f / rangedHaste - 1.0f) * mod->Coeff;
        case 3:
            return (1.0f / spellHaste - 1.0f) * mod->Coeff;
        case 4:
            return (1.0f / regenHaste - 1.0f) * mod->Coeff;
        case 5:
            return (1.0f / std::min(std::min(std::min(haste, rangedHaste), spellHaste), regenHaste) - 1.0f) * mod->Coeff;
        default:
            break;
    }

    return 0.0f;
}

inline float CalcPPMCritMod(SpellProcsPerMinuteModEntry const* mod, Unit* caster)
{
    if (caster->GetTypeId() != TYPEID_PLAYER)
        return 0.0f;

    float crit = caster->GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE);
    float rangedCrit = caster->GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE);
    float spellCrit = caster->GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);

    switch (mod->Param)
    {
        case 1:
            return crit * mod->Coeff * 0.01f;
        case 2:
            return rangedCrit * mod->Coeff * 0.01f;
        case 3:
            return spellCrit * mod->Coeff * 0.01f;
        case 4:
            return std::min(std::min(crit, rangedCrit), spellCrit) * mod->Coeff * 0.01f;
        default:
            break;
    }

    return 0.0f;
}

inline float CalcPPMItemLevelMod(SpellProcsPerMinuteModEntry const* mod, int32 itemLevel)
{
    if (uint32(itemLevel) == mod->Param)
        return 0.0f;

    float itemLevelPoints = GetRandomPropertyPoints(itemLevel, ITEM_QUALITY_RARE, INVTYPE_CHEST, 0);
    float basePoints = GetRandomPropertyPoints(mod->Param, ITEM_QUALITY_RARE, INVTYPE_CHEST, 0);
    if (itemLevelPoints == basePoints)
        return 0.0f;

    return ((itemLevelPoints / basePoints) - 1.0f) * mod->Coeff;
}

float SpellInfo::CalcProcPPM(float ppm, Unit* caster, int32 itemLevel) const
{
    for (SpellProcsPerMinuteModEntry const* mod : ProcPPMMods)
    {
        switch (mod->Type)
        {
            case SPELL_PPM_MOD_HASTE:
            {
                ppm *= 1.0f + CalcPPMHasteMod(mod, caster);
                break;
            }
            case SPELL_PPM_MOD_CRIT:
            {
                ppm *= 1.0f + CalcPPMCritMod(mod, caster);
                break;
            }
            case SPELL_PPM_MOD_CLASS:
            {
                if (caster->getClassMask() & mod->Param)
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_SPEC:
            {
                if (Player* plrCaster = caster->ToPlayer())
                    if (plrCaster->GetSpecializationId() == mod->Param)
                        ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_RACE:
            {
                if (caster->getRaceMask() & mod->Param)
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_ITEM_LEVEL:
            {
                ppm *= 1.0f + CalcPPMItemLevelMod(mod, itemLevel);
                break;
            }
            case SPELL_PPM_MOD_BATTLEGROUND:
            {
                if (caster->GetMap()->IsBattlegroundOrArena())
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            default:
                break;
        }
    }

    return ppm;
}

bool SpellInfo::IsRanked() const
{
    return ChainEntry != NULL;
}

uint8 SpellInfo::GetRank() const
{
    if (!ChainEntry)
        return 1;
    return ChainEntry->rank;
}

SpellInfo const* SpellInfo::GetFirstRankSpell() const
{
    if (!ChainEntry)
        return this;
    return ChainEntry->first;
}
SpellInfo const* SpellInfo::GetLastRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->last;
}
SpellInfo const* SpellInfo::GetNextRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->next;
}
SpellInfo const* SpellInfo::GetPrevRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->prev;
}

SpellInfo const* SpellInfo::GetAuraRankForLevel(uint8 level) const
{
    // ignore passive spells
    if (IsPassive())
        return this;

    bool needRankSelection = false;
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (IsPositiveEffect(i) &&
            (Effects[i].Effect == SPELL_EFFECT_APPLY_AURA ||
            Effects[i].Effect == SPELL_EFFECT_APPLY_AURA_ON_PET ||
            Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
            Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID) &&
            !Effects[i].ScalingMultiplier)
        {
            needRankSelection = true;
            break;
        }
    }

    // not required
    if (!needRankSelection)
        return this;

    for (SpellInfo const* nextSpellInfo = this; nextSpellInfo != NULL; nextSpellInfo = nextSpellInfo->GetPrevRankSpell())
    {
        // if found appropriate level
        if (uint32(level + 10) >= nextSpellInfo->SpellLevel)
            return nextSpellInfo;

        // one rank less then
    }

    // not found
    return NULL;
}

bool SpellInfo::IsRankOf(SpellInfo const* spellInfo) const
{
    return spellInfo && GetFirstRankSpell() == spellInfo->GetFirstRankSpell();
}

bool SpellInfo::IsDifferentRankOf(SpellInfo const* spellInfo) const
{
    if (Id == spellInfo->Id)
        return false;
    return IsRankOf(spellInfo);
}

bool SpellInfo::IsHighRankOf(SpellInfo const* spellInfo) const
{
    if (ChainEntry && spellInfo->ChainEntry)
    {
        if (ChainEntry->first == spellInfo->ChainEntry->first)
            if (ChainEntry->rank > spellInfo->ChainEntry->rank)
                return true;
    }
    return false;
}

uint32 SpellInfo::_GetExplicitTargetMask() const
{
    bool srcSet = false;
    bool dstSet = false;
    uint32 targetMask = Targets;
    // prepare target mask using effect target entries
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (!Effects[i].IsEffect())
            continue;

        if (Effects[i].TargetA.GetTarget() >= TOTAL_SPELL_TARGETS)
        {
            printf("%u SPELL_TARGET overflow!! %d\r\n", Id, Effects[i].TargetA.GetTarget());
            continue;
        }

        targetMask |= Effects[i].TargetA.GetExplicitTargetMask(srcSet, dstSet);
        targetMask |= Effects[i].TargetB.GetExplicitTargetMask(srcSet, dstSet);

        // add explicit target flags based on spell effects which have EFFECT_IMPLICIT_TARGET_EXPLICIT and no valid target provided
        if (Effects[i].GetImplicitTargetType() != EFFECT_IMPLICIT_TARGET_EXPLICIT)
            continue;

        // extend explicit target mask only if valid targets for effect could not be provided by target types
        uint32 effectTargetMask = Effects[i].GetMissingTargetMask(srcSet, dstSet, targetMask);

        // don't add explicit object/dest flags when spell has no max range
        if (GetMaxRange(true) == 0.0f && GetMaxRange(false) == 0.0f)
            effectTargetMask &= ~(TARGET_FLAG_UNIT_MASK | TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_CORPSE_MASK | TARGET_FLAG_DEST_LOCATION);
        targetMask |= effectTargetMask;
    }
    return targetMask;
}

bool SpellInfo::IsAllwaysStackModifers() const
{
    if (IsPassive())
        return true;

    if (SpellFamilyName == SPELLFAMILY_POTION)
        return true;

    switch (Id)
    {
        // warsong flags
        case 23333:
        case 23335:

        case 16191: // mana tide buff
            return true;
       default:
            break;
    }
    return false;
}

bool SpellInfo::_IsPositiveEffect(uint8 effIndex, bool deep) const
{
    // not found a single positive spell with this attribute
    if (Attributes & SPELL_ATTR0_DEBUFF)
        return false;

    switch (SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
            switch (Id)
            {
                case 29214: // Wrath of the Plaguebringer
                case 34700: // Allergic Reaction
                case 54836: // Wrath of the Plaguebringer
                case 61987: // Avenging Wrath Marker
                case 61988: // Divine Shield exclude aura
                case 69708: // Ice Prison (HoR)
                case 70194: // Dark Arrow (HoR)
                case 70070: // Harvest Soul (HoR)
                case 47310: // Direbrew's Disarm
                    return false;
                case 30877: // Tag Murloc
                case 61716: // Rabbit Costume
                case 61734: // Noblegarden Bunny
                case 62344: // Fists of Stone
                case 62478: // Frozen Blows (Hodir)
                case 63512: // Frozen Blows (Hodir)
                case 73523: // Rigor Mortis
                case 24732: // Nananananana... Bat Costume!
                case 24740: // Wisp Costume
                    return true;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_MAGE:
            // Dampen Magic
            if (SpellFamilyFlags[0] == 0x00002000)
                return true;
            // Ignite
            if (SpellIconID == 45)
                return true;
            break;
        case SPELLFAMILY_WARLOCK:
            switch (Id)
            {
                case 111400: ///< Burning Rush
                    return true;
                default:
                    break;
            }
        case SPELLFAMILY_PRIEST:
            switch (Id)
            {
                case 64844: ///< Divine Hymn
                case 47585: ///< Dispersion
                    return true;
                default:
                    break;
            }
            break;
        default:
            break;
    }

    switch (Mechanic)
    {
        case MECHANIC_IMMUNE_SHIELD:
            return true;
        default:
            break;
    }

    // Special case: effects which determine positivity of whole spell
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsAura() && Effects[i].ApplyAuraName == SPELL_AURA_MOD_STEALTH)
            return true;
    }

    switch (Effects[effIndex].Effect)
    {
        case SPELL_EFFECT_DUMMY:
            // some explicitly required dummy effect sets
            switch (Id)
            {
                case 28441:
                    return false; // AB Effect 000
                default:
                    break;
            }
            break;
        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_LEARN_SPELL:
        case SPELL_EFFECT_SKILL_STEP:
        case SPELL_EFFECT_HEAL_PCT:
        case SPELL_EFFECT_ENERGIZE_PCT:
            return true;
        case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
            return false;

            // non-positive aura use
        case SPELL_EFFECT_APPLY_AURA:
        case SPELL_EFFECT_APPLY_AURA_ON_PET:
        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
        {
            switch (Effects[effIndex].ApplyAuraName)
            {
                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
                case SPELL_AURA_MOD_STAT:
                case SPELL_AURA_MOD_SKILL:
                case SPELL_AURA_MOD_DODGE_PERCENT:
                case SPELL_AURA_MOD_HEALING_PCT:
                case SPELL_AURA_MOD_HEALING_DONE:
                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
                    if (Effects[effIndex].CalcValue() < 0)
                        return false;
                    break;
                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
                    if (Effects[effIndex].CalcValue() > 0)
                        return false;
                    break;
                case SPELL_AURA_MOD_CRIT_PCT:
                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
                    if (Effects[effIndex].CalcValue() > 0)
                        return true;                        // some expected positive spells have SPELL_ATTR1_NEGATIVE
                    break;
                case SPELL_AURA_ADD_TARGET_TRIGGER:
                    return true;
                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
                    if (!deep)
                    {
                        if (SpellInfo const* spellTriggeredProto = sSpellMgr->GetSpellInfo(Effects[effIndex].TriggerSpell))
                        {
                            // negative targets of main spell return early
                            for (uint8 i = 0; i < EffectCount; ++i)
                            {
                                if (!spellTriggeredProto->Effects[i].Effect)
                                    continue;
                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
                                // this will place this spell auras as debuffs
                                if (_IsPositiveTarget(spellTriggeredProto->Effects[i].TargetA.GetTarget(), spellTriggeredProto->Effects[effIndex].TargetB.GetTarget()) && !spellTriggeredProto->_IsPositiveEffect(i, true))
                                    return false;
                            }
                        }
                    }
                case SPELL_AURA_PROC_TRIGGER_SPELL:
                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
                    break;
                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
                    if (effIndex == 0 && Effects[1].Effect == 0 && Effects[2].Effect == 0)
                        return false;                       // but all single stun aura spells is negative
                    break;
                case SPELL_AURA_MOD_PACIFY_SILENCE:
                    if (Id == 24740)             // Wisp Costume
                        return true;
                    return false;
                case SPELL_AURA_MOD_ROOT:
                case SPELL_AURA_MOD_ROOT_2:
                case SPELL_AURA_MOD_SILENCE:
                case SPELL_AURA_GHOST:
                case SPELL_AURA_PERIODIC_LEECH:
                case SPELL_AURA_MOD_STALKED:
                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
                case SPELL_AURA_PREVENT_RESURRECTION:
                    return false;
                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
                    // part of negative spell if casted at self (prevent cancel)
                    if (Effects[effIndex].TargetA.GetTarget() == TARGET_UNIT_CASTER)
                        return false;
                    break;
                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
                    // part of positive spell if casted at self
                    if (Effects[effIndex].TargetA.GetTarget() != TARGET_UNIT_CASTER)
                        return false;
                    // but not this if this first effect (didn't find better check)
                    if (Attributes & SPELL_ATTR0_DEBUFF && effIndex == 0)
                        return false;
                    break;
                case SPELL_AURA_MECHANIC_IMMUNITY:
                {
                    // non-positive immunities
                    switch (Effects[effIndex].MiscValue)
                    {
                        case MECHANIC_BANDAGE:
                        case MECHANIC_SHIELD:
                        case MECHANIC_MOUNT:
                        case MECHANIC_INVULNERABILITY:
                            return false;
                        default:
                            break;
                    }
                    break;
                }
                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
                case SPELL_AURA_ADD_PCT_MODIFIER:
                {
                    // non-positive mods
                    switch (Effects[effIndex].MiscValue)
                    {
                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
                            if (Effects[effIndex].CalcValue() > 0)
                            {
                                if (!deep)
                                {
                                    bool negative = true;
                                    for (uint8 i = 0; i < EffectCount; ++i)
                                    {
                                        if (i != effIndex)
                                            if (_IsPositiveEffect(i, true))
                                            {
                                                negative = false;
                                                break;
                                            }
                                    }
                                    if (negative)
                                        return false;
                                }
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:
            break;
    }

    // non-positive targets
    if (!_IsPositiveTarget(Effects[effIndex].TargetA.GetTarget(), Effects[effIndex].TargetB.GetTarget()))
        return false;

    // negative spell if triggered spell is negative
    if (!deep && !Effects[effIndex].ApplyAuraName && Effects[effIndex].TriggerSpell)
    {
        if (SpellInfo const* spellTriggeredProto = sSpellMgr->GetSpellInfo(Effects[effIndex].TriggerSpell))
            if (!spellTriggeredProto->_IsPositiveSpell())
                return false;
    }

    // ok, positive
    return true;
}

bool SpellInfo::_IsPositiveSpell() const
{
    // spells with at least one negative effect are considered negative
    // some self-applied spells have negative effects but in self casting case negative check ignored.
    for (uint8 i = 0; i < EffectCount; ++i)
        if (!_IsPositiveEffect(i, true))
            return false;

    return true;
}

bool SpellInfo::_IsPositiveTarget(uint32 p_TargetA, uint32 p_TargetB)
{
    /// Non-positive targets
    switch (p_TargetA)
    {
        case Targets::TARGET_UNIT_NEARBY_ENEMY:
        case Targets::TARGET_UNIT_TARGET_ENEMY:
        case Targets::TARGET_UNIT_SRC_AREA_ENEMY:
        case Targets::TARGET_UNIT_DEST_AREA_ENEMY:
        case Targets::TARGET_UNIT_CONE_ENEMY_24:
        case Targets::TARGET_UNIT_CONE_ENEMY_104:
        case Targets::TARGET_UNIT_CONE_ENEMY_110:
        case Targets::TARGET_UNIT_CONE_ENEMY_129:
        case Targets::TARGET_UNIT_CONE_ENEMY_130:
        case Targets::TARGET_DEST_DYNOBJ_ENEMY:
        case Targets::TARGET_DEST_TARGET_ENEMY:
        case Targets::TARGET_ENNEMIES_AROUND_CASTER:
            return false;
        default:
            break;
    }

    if (p_TargetB)
        return _IsPositiveTarget(p_TargetB, 0);

    return true;
}

SpellTargetRestrictionsEntry const* SpellInfo::GetSpellTargetRestrictions() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellTargetRestrictionsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellTargetRestrictionsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellTargetRestrictionsId ? sSpellTargetRestrictionsStore.LookupEntry(SpellTargetRestrictionsId) : nullptr;
}

SpellEquippedItemsEntry const* SpellInfo::GetSpellEquippedItems() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellEquippedItemsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellEquippedItemsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellEquippedItemsId ? sSpellEquippedItemsStore.LookupEntry(SpellEquippedItemsId) : nullptr;
}

SpellInterruptsEntry const* SpellInfo::GetSpellInterrupts() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellInterruptsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellInterruptsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellInterruptsId ? sSpellInterruptsStore.LookupEntry(SpellInterruptsId) : nullptr;
}

SpellLevelsEntry const* SpellInfo::GetSpellLevels() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellLevelsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellLevelsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellLevelsId ? sSpellLevelsStore.LookupEntry(SpellLevelsId) : nullptr;
}

SpellPowerEntry const* SpellInfo::GetSpellPower() const
{
    return sSpellPowerStore.LookupEntry(Id);
}

SpellMiscEntry const* SpellInfo::GetSpellMisc() const
{
    return SpellMiscId ? sSpellMiscStore.LookupEntry(SpellMiscId) : nullptr;
}

SpellReagentsEntry const* SpellInfo::GetSpellReagents() const
{
    return SpellReagentsId ? sSpellReagentsStore.LookupEntry(SpellReagentsId) : nullptr;
}

SpellScalingEntry const* SpellInfo::GetSpellScaling() const
{
    return SpellScalingId ? sSpellScalingStore.LookupEntry(SpellScalingId) : nullptr;
}

SpellShapeshiftEntry const* SpellInfo::GetSpellShapeshift() const
{
    return SpellShapeshiftId ? sSpellShapeshiftStore.LookupEntry(SpellShapeshiftId) : nullptr;
}

SpellTotemsEntry const* SpellInfo::GetSpellTotems() const
{
    return SpellTotemsId ? sSpellTotemsStore.LookupEntry(SpellTotemsId) : nullptr;
}

SpellAuraOptionsEntry const* SpellInfo::GetSpellAuraOptions() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellAuraOptionsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellAuraOptionsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellAuraOptionsId ? sSpellAuraOptionsStore.LookupEntry(SpellAuraOptionsId) : nullptr;
}

SpellAuraRestrictionsEntry const* SpellInfo::GetSpellAuraRestrictions() const
{
    return SpellAuraRestrictionsId ? sSpellAuraRestrictionsStore.LookupEntry(SpellAuraRestrictionsId) : nullptr;
}

SpellCastingRequirementsEntry const* SpellInfo::GetSpellCastingRequirements() const
{
    return SpellCastingRequirementsId ? sSpellCastingRequirementsStore.LookupEntry(SpellCastingRequirementsId) : nullptr;
}

SpellCategoriesEntry const* SpellInfo::GetSpellCategories() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellCategoriesStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellCategoriesStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellCategoriesId ? sSpellCategoriesStore.LookupEntry(SpellCategoriesId) : nullptr;
}

SpellClassOptionsEntry const* SpellInfo::GetSpellClassOptions() const
{
    return SpellClassOptionsId ? sSpellClassOptionsStore.LookupEntry(SpellClassOptionsId) : nullptr;
}

SpellCooldownsEntry const* SpellInfo::GetSpellCooldowns() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellCooldownsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellCooldownsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellCooldownsId ? sSpellCooldownsStore.LookupEntry(SpellCooldownsId) : nullptr;
}

SpellEffectEntry const* SpellEntry::GetSpellEffect(uint32 eff, uint32 difficulty) const
{
    return GetSpellEffectEntry(Id, eff, difficulty);
}

void SpellInfo::SetDurationIndex(uint32 index)
{
    SpellDurationEntry const* durationIndex = sSpellDurationStore.LookupEntry(index);
    if (!durationIndex)
        return;

    DurationEntry = durationIndex;
}

void SpellInfo::SetRangeIndex(uint32 index)
{
    SpellRangeEntry const* rangeIndex = sSpellRangeStore.LookupEntry(index);
    if (!rangeIndex)
        return;

    RangeEntry = rangeIndex;
}

void SpellInfo::SetCastTimeIndex(uint32 index)
{
    SpellCastTimesEntry const* castTimeIndex = sSpellCastTimesStore.LookupEntry(index);
    if (!castTimeIndex)
        return;

    CastTimeEntry = castTimeIndex;
}

void SpellInfo::_UnloadImplicitTargetConditionLists()
{
    // find the same instances of ConditionContainer and delete them.
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        ConditionContainer* cur = Effects[i].ImplicitTargetConditions;
        if (!cur)
            continue;

        for (uint8 j = i; j < EffectCount; ++j)
        {
            if (Effects[j].ImplicitTargetConditions == cur)
                Effects[j].ImplicitTargetConditions = NULL;
        }
        delete cur;
    }
}

bool SpellInfo::_IsCrowdControl(uint8 effMask, bool nodamage) const
{
    for (uint8 effIndex = 0; effIndex < EffectCount; ++effIndex)
    {
        if (effMask && !(effMask & (1 << effIndex)))
            continue;

        if (nodamage)
        {
            switch (Effects[effIndex].Effect)
            {
                case SPELL_EFFECT_HEALTH_LEECH:
                case SPELL_EFFECT_SCHOOL_DAMAGE:
                    return false;
            }
        }

        switch (Effects[effIndex].ApplyAuraName)
        {
            case SPELL_AURA_MOD_STUN:
                switch (SpellIconID)
                {
                    case 15:
                    case 457:
                        return false;
                    default:
                        break;
                }
            case SPELL_AURA_MOD_CONFUSE:
            case SPELL_AURA_MOD_FEAR:
            case SPELL_AURA_MOD_FEAR_2:
            case SPELL_AURA_MOD_ROOT:
            case SPELL_AURA_MOD_ROOT_2:
            case SPELL_AURA_TRANSFORM:
                if (!IsPositive())
                    return true;
                break;
            default: break;
        }
    }
    return false;
}

bool SpellInfo::_IsNeedDelay() const
{
    switch (Id)
    {
        case 379:   // Earth Shield (Shaman)
        case 14161: // Ruthlessness (Rogue)
        case 33110: // Prayer of Mending (Priest)
        case 48503: // Living Seed (Druid)
        case 52752: // Ancestral Awakening (Shaman)
        case 62836: // Slag Imbued (Ignis, Ulduar)
        case 63536: // Slag Imbued (Ignis, Ulduar)
        case 70802: // Mayhem (Rogue)
        case 70157: // Ice Tomb (Sindragosa, ICC)
        case 79128: // Improved Expose Armor
        case 36032: // Arcane Blast
        case 109950: // Fury of Destroyer
        case 139546: // Add combo point (for Ruthlessness)
        //case 114157: // Execution Sentence
            return true;
    }

    // Flurry (Shaman)
    if (SpellFamilyName == SPELLFAMILY_SHAMAN && SpellIconID == 108)
        return true;

    return false;
}

bool SpellInfo::IsBreakingCamouflageAfterHit() const
{
    // Traps
    if (SpellFamilyFlags[1] & 0x8002000 ||
        SpellFamilyFlags[2] & 0x20000)
        return true;

    // Damage casts
    switch (Id)
    {
        case 19434: // Aimed Shot
        case 82928: // Aimed Shot
        case 77767: // Cobra Shot
        case 56641: // Steady Shot
            return true;
    }

    return false;
}

bool SpellInfo::IsBreakingCamouflage() const
{
    // This is bad but I dont't see another way
    // I cannot check spells using any mask
    // Use it only for hunter camouflage
    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificFood:
        case SpellSpecificType::SpellSpecificFoodAndDrink:
        case SpellSpecificType::SpellSpecificWellFed:
        case SpellSpecificType::SpellSpecificAspect:
            return false;
    }

    switch (Id)
    {
        case 136:   // Mend Pet
        case 982:   // Revive Pet
        case 1130:  // Hunter's Mark
        case 1462:  // Beast Lore
        case 1499:  // Frost Trap
        case 1543:  // Flare
        case 3045:  // Rapid Fire
        case 5384:  // Feign Death
        case 6197:  // Eagle Eye
        case 6991:  // Feed Pet
        case 13795: // Immolation Trap
        case 13809: // Ice Trap
        case 13813: // Explosive Trap
        case 19263: // Deterence
        case 19434: // Aimed Shot
        case 23989: // Readiness
        case 26297: // Berserking (Troll Racial)
        case 34477: // Misdirection
        case 34600: // Snake Trap
        case 42292: // PvP Trinket
        case 53271: // Master's Call
        case 56641: // Steady Shot
        case 60192: // Frost Trap launcher
        case 77767: // Cobra Shot
        case 77769: // Trap Launcher
        case 82935: // Immplation Trap launcher
        case 82939: // Explosive Trap launcher
        case 82941: // Ice Trap launcher
        case 82945: // Immolation Trap Launcher
        case 82948: // Snake Trap launcher
        case 93435: // Roar of Courage (Special Ability)
            return false;
    }

    return true;
}

bool SpellInfo::IsIgnoringCombat() const
{
    if (HasAttribute(SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS))
        return true;

    /// Polymorph spells shouldn't give combat
    if (Mechanic == MECHANIC_POLYMORPH)
        return true;

    switch (Id)
    {
        /// Meteor
        case 153561:
        /// Marked for Death
        case 137619:
        /// Slice and Dice
        case 5171:
        case 6434:
        case 6774:
        /// Honor Among Thieves
        case 51698:
        case 51699:
        case 51700:
        case 51701:
        case 52916:
        /// Divine Hymn
        case 64843:
        case 64844:
        case 70619:
        /// Shadowmeld
        case 58984:
        /// Blackjack
        case 79124:
        case 79126:
        /// Venomous Wounds
        case 79136:
        /// Master Poisoner
        case 93068:
        /// Blind
        case 2094:
        /// Ignite
        case 12654:
        /// Resistance is Futile
        case 83676:
        /// Vendeta
        case 79140:
        /// Earth Shield
        case 379:
        /// Earthliving Weapon proc
        case 51730:
        /// Ancestral Vigor
        case 105284:
        /// Ancestral Fortitude
        case 16177:
        case 16236:
         /// Ysera's Gift
        case 145110:
            return true;
        default: break;
    }

    // Dark Intent
    if (SpellFamilyName == SPELLFAMILY_WARLOCK && (SpellFamilyFlags[2] & 0x00800000))
        return true;

    return false;
}

bool SpellInfo::IsAfflictionPeriodicDamage() const
{
    switch (Id)
    {
        case 172:   // Corruption
        case 146739:// Corruption
        case 980:   // Agony
        case 30108: // Unstable Affliction
        case 131736:// Unstable Affliction (triggered)
        case 131737:// Agony (triggered)
        case 131740:// Corruption (triggered)
            return true;
        default:
            return false;
    }
}

float SpellInfo::GetGiftOfTheSerpentScaling(Unit* caster) const
{
    float scale = 1.0f;

    switch (Id)
    {
        case 117640:// Spinning Crane Kick (Heal)
            scale = 0.1f;
            break;
        case 124040:// Chi Torpedo
        case 124101:// Zen Sphere : Detonate
        case 130654:// Chi Burst (Heal)
            scale = 0.15f;
            break;
        case 117895:// Eminence
        case 132120:// Enveloping Mist
            scale = 0.2f;
            break;
        case 115151:// Renewing Mist
        case 119611:// Renewing Mist (HoT)
        case 116670:// Uplift
        case 124081:// Zen Sphere (HoT)
        case 132463:// Chi Wave (Heal)
            scale = 0.25f;
            break;
        case 115175:// Soothing Mist
            scale = 0.3f;
            break;
        default:
            break;
    }

    // Serpent Statue has different scaling
    if (caster->GetTypeId() == TYPEID_UNIT && caster->ToUnit()->GetEntry() == 60849)
    {
        switch (Id)
        {
            case 117895:// Eminence
                scale = 0.1f;
                break;
            case 115175:// Soothing Mist
                scale = 0.15f;
                break;
            default:
                break;
        }
    }

    return scale;
}

float SpellInfo::GetCastTimeReduction() const
{
    return 1.0f;
}

bool SpellInfo::CanTriggerBladeFlurry() const
{
    switch (Id)
    {
        case 1752:  // Sinister Strike
        case 2098:  // Eviscerate
        case 5374:  // Mutilate
        case 5938:  // Shiv
        case 8676:  // Ambush
        case 26679: // Deadly Throw
        case 27576: // Mutilate Off-Hand
        case 51723: // Fan of Knives
        case 57841: // Killing Spree
        case 57842: // Killing Spree Off-Hand
        case 84617: // Revealing Strike
        case 114014:// Shuriken Toss
        case 121411:// Crimson Tempest
        case 121473:// Shadow Blade
        case 121474:// Shadow Blade Off-Hand
            return true;
    }

    return false;
}

bool SpellInfo::IsCustomCharged(SpellInfo const* procSpell, Unit* caster) const
{
    switch (Id)
    {
        case 16246: // Clearcasting (Shaman)
            if (procSpell && procSpell->Id == 8004)
                return true;
            break;
        case 20066: // Repentence
            if (procSpell && procSpell->Id == 31803)
                return true;
            break;
        case 324:   // Lightning Shield
        case 36032: // Arcane Charge
        case 79683: // Arcane Missiles !
        case 93400: // Shooting Stars
        case 114637:// Bastion of Glory
        case 60503: // Overpower !
        case 121153:// Blindside
        case 131116:// Raging Blow !
        case 134563:// Healing Elixirs
            return true;
        case 115191:// Stealth (Subterfuge)
            if (caster->HasAura(115192)) // Subterfuge buff - 3s
                return true;
            break;
        case 165442:///< Crusader's Fury
            if (procSpell && procSpell->Id == 157048) ///< Final Verdict
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsCustomCastCanceled(Unit* caster) const
{
    switch (Id)
    {
        case 22778: // Hamstring Rage Reduction
            if (caster->HasAura(Id))
                return true;
            break;
        case 32973: // Gloves S12 - Shaman
            if (caster->HasAura(Id))
                return true;
            break;
        case 33830: // Gloves S12 - Druid
            if (caster->HasAura(Id))
                return true;
            break;
        case 44297: // Gloves S12 - Priest
            if (caster->HasAura(Id))
                return true;
            break;
        case 131562:// Item Monk - 2P S12 Windwalker
            if (caster->HasAura(Id))
                return true;
            break;
    }

    return false;
}

bool SpellInfo::IsWrongPrecastSpell(SpellInfo const* m_preCastSpell) const
{
    switch (Id)
    {
        case 51723: // Fan of Knives
            if (m_preCastSpell->Id == 51690)
                return true;
            break;
        case 108507:// Kil'Jaeden's Cunning
            if (m_preCastSpell->Id == 119048)
                return true;
            break;
        case 115072:// Expel Harm
        case 147489:// Expel Harm with glyph of Targeted Expulsion
            if (m_preCastSpell->Id == 101545)
                return true;
            break;
        case 118858:// Incanter's Ward
            if (m_preCastSpell->Id == 118859)
                return true;
            break;
        case 119050:// Kil'Jaeden's Cunning (Decrease speed)
            if (m_preCastSpell->Id == 119049)
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsPoisonOrBleedSpell() const
{
    switch (Id)
    {
        case 703:   ///< Garrote
        case 1943:  ///< Rupture
        case 2818:  ///< Deadly Poison (DoT)
        case 3409:  ///< Crippling Poison
        case 8680:  ///< Wound Poison
        case 16511: ///< Hemorrhage (DoT)
        case 79136: ///< Venomous Wound (damage)
        case 112961:///< Leeching Poison
        case 113780:///< Deadly Poison (direct damage)
        case 122233:///< Crimson Tempest (DoT)
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsCustomChecked() const
{
    switch (Id)
    {
        case 136955:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136956:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136957:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136958:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136959:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136960:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138671:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138672:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138673:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138674:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138675:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138676:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsBattleResurrection() const
{
    return AttributesEx8 & SpellAttr8::SPELL_ATTR8_BATTLE_RESURRECTION;
}

bool SpellInfo::IsFinishingMove() const
{
    switch (Id)
    {
        case 5171: ///< slice  and dice
        case 73651: ///< recuperate
            return true;
        default:
            break;
    }

    return IsOffensiveFinishingMove();
}

bool SpellInfo::IsOffensiveFinishingMove() const
{
    switch (Id)
    {
        case 408: ///< kidney shot
        case 1943: ///< rupture
        case 2098: ///< eviscerate
        case 26679: ///< deadly throw
        case 32645: ///< envenom
        case 121411: ///< crimson tempest
        case 152150: ///< death from above
            return true;
        default:
            return false;
    }
}

bool SpellInfo::IsArcaneTorrent() const
{
    switch (Id)
    {
        case 25046: ///< Energy
        case 28730: ///< Mana
        case 50613: ///< Runic Power
        case 69179: ///< Rage
        case 80483: ///< Focus
        case 129597: ///< Chi
        case 155145: ///< Holy Power
            return true;
        default:
            return false;
    }
}

bool SpellInfo::IsCanBeStolen() const
{
    /// Special rules, some aren't using mana but can be stolen
    switch (Id)
    {
        case 633:   ///< Lay on Hands
        case 22812: ///< Barkskin
        case 24275: ///< Hammer of Wrath
        case 158392: ///< Hammer of Wrath
        case 31935: ///< Avenger's Shield
        case 53563: ///< Beacon of Light
            return false;
        case 642:   ///< Divine Shield
        case 5484:  ///< Howl of Terror
        case 12472: ///< Icy Veins
        case 51490: ///< Thunderstorm
        case 64044: ///< Psychic Horror
            return true;
        default:
            break;
    }

    /// Some of the rules for those spells that can be stolen by Dark Simulacrum
    /// Spells should use mana
    bool l_UseMana = false;
    for (auto l_Iter : SpellPowers)
    {
        if (l_Iter->PowerType != POWER_MANA)
            return false;

        /// And should have mana cost
        if (!l_Iter->Cost && !l_Iter->CostBasePercentage)
            return false;

        l_UseMana = true;
        break;
    }

    if (!l_UseMana)
        return false;

    for (uint8 l_I = 0; l_I < SpellEffIndex::MAX_EFFECTS; ++l_I)
    {
        switch (Effects[l_I].Effect)
        {
            case SPELL_EFFECT_SUMMON:
            case SPELL_EFFECT_SUMMON_PET:
            case SPELL_EFFECT_CAST_BUTTON:
            case SPELL_EFFECT_TAMECREATURE:
            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
                return false;
            case SPELL_EFFECT_SCHOOL_DAMAGE:
                if (DmgClass == SPELL_DAMAGE_CLASS_MELEE)
                    return false;
                break;
            case SPELL_EFFECT_APPLY_AURA:
                if (Effects[l_I].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
                    return false;
                break;
            default:
                break;
        }
    }

    return true;
}

bool SpellInfo::IsNeedAdditionalLosChecks() const
{
    if (HasEffect(SPELL_EFFECT_KNOCK_BACK))
        return true;

    switch(Id)
    {
        case 3600:  // Earthbind Totem
        case 50622:
        case 44949: // Whirlwind from bladestorm
        case 23455: // Holy Nova
        case 87204: // Sin and Punishment proc
        case 117418: // Fists of Fury
        case 120086: // Fists of Fury (Stun)
            return true;
        default:break;
    }

    return false;
}

bool SpellInfo::IsRequireAdditionalTargetCheck() const
{
    switch (Id)
    {
        case 2812: // Holy Wrath
            return false;
        case 103327: // Hour of Twilight dmg, Ultraxion, Dragon Soul
            return false;
        default:
            break;
    }

    return true;
}

bool SpellInfo::IsBreakingStealth(Unit* m_caster) const
{
    if (!m_caster)
        return false;

    if (m_caster->HasAura(115192))
        return false;

    /// Hearthstone shouldn't call subterfuge effect
    if ((SpellIconID == 776 || SpellFamilyName == SPELLFAMILY_POTION) && m_caster->HasAura(115191))
    {
        m_caster->RemoveAura(115191);
        return true;
    }

    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificFood:
        case SpellSpecificType::SpellSpecificFoodAndDrink:
        case SpellSpecificType::SpellSpecificWellFed:
            return true;
        default:
            break;
    }

    bool callSubterfuge = true;
    if (m_caster->HasAura(108208) && m_caster->HasAura(115191) && !m_caster->HasAura(115192) &&
        !HasAttribute(SPELL_ATTR1_NOT_BREAK_STEALTH) && !m_caster->HasAura(51713) && Id != 127802)
    {
        /// Mounts shouldn't call subterfuge effect
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
            {
                callSubterfuge = false;
                break;
            }
        }

        if (callSubterfuge)
        {
            m_caster->CastSpell(m_caster, 115192, true);
            return true;
        }
    }

    if (m_caster->HasAura(115191))
        return false;

    switch (Id)
    {
        case 99:    ///< Incapaciting Roar
        case 2643:  ///< Multi-shot
        case 3600:  ///< Earthbind
        case 12323: ///< Piercing Howl
        case 50256: ///< Invigorating Roar (Special Ability)
        case 64695: ///< Earthgrab
            return false;
        default:
            break;
    }

    if (IsTargetingArea())
    {
        /// Dispel etc spells
        switch (Effects[EFFECT_0].Effect)
        {
            case SPELL_EFFECT_DISPEL:
            case SPELL_EFFECT_DISPEL_MECHANIC:
            case SPELL_EFFECT_THREAT:
            case SPELL_EFFECT_MODIFY_THREAT_PERCENT:
            case SPELL_EFFECT_DISTRACT:
                return false;
            default:
                break;
        }
    }

    if (HasAttribute(SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS) || HasAttribute(SPELL_ATTR1_NOT_BREAK_STEALTH))
        return false;

    return true;
}

bool SpellInfo::IsPeriodicHeal() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].ApplyAuraName == SPELL_AURA_PERIODIC_HEAL)
            return true;
    }

    return false;
}

bool SpellInfo::IsPeriodic() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
       if (Effects[i].IsPeriodicEffect())
           return true;
    }
    return false;
}

bool SpellEffectInfo::IsPeriodicEffect() const
{
    if (!ApplyAuraName)
        return false;

    switch (ApplyAuraName)
    {
        case SPELL_AURA_PERIODIC_DUMMY:
        case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
        case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
        case SPELL_AURA_PERIODIC_DAMAGE:
        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
        case SPELL_AURA_PERIODIC_LEECH:
        case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
        case SPELL_AURA_PERIODIC_HEAL:
        case SPELL_AURA_OBS_MOD_HEALTH:
        case SPELL_AURA_PERIODIC_MANA_LEECH:
        case SPELL_AURA_OBS_MOD_POWER:
        case SPELL_AURA_PERIODIC_ENERGIZE:
        case SPELL_AURA_POWER_BURN:
            return true;
    }

    return false;
}

bool SpellEffectInfo::CanScale() const
{
    switch (Effect)
    {
        case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
        case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
        case SPELL_EFFECT_APPLY_AREA_AURA_PET:
        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
        case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
        case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
        case SPELL_EFFECT_APPLY_AURA:
        case SPELL_EFFECT_APPLY_AURA_ON_PET:
        {
            switch (ApplyAuraName)
            {
                case SPELL_AURA_PERIODIC_DAMAGE:
                case SPELL_AURA_PERIODIC_HEAL:
                case SPELL_AURA_DAMAGE_SHIELD:
                case SPELL_AURA_SCHOOL_ABSORB:
                case SPELL_AURA_SCHOOL_HEAL_ABSORB:
                {
                    switch (_spellInfo->Id)
                    {
                        case 162184: ///< Expel Magic: Shadow - Highmaul (Ko'ragh)
                            return false;
                        default:
                            break;
                    }

                    return true;
                }
                case SPELL_AURA_DUMMY:
                {
                    switch (_spellInfo->Id)
                    {
                        // Earthquake
                        case 61882:
                            return true;
                        default:
                            break;
                    }
                }
                default:
                    break;
            }

            break;
        }
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_POWER_DRAIN:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_WEAPON_DAMAGE:
        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
        case SPELL_EFFECT_PERSISTENT_AREA_AURA:
            return true;
    }

    return false;
}

bool SpellInfo::IsInterruptSpell() const
{
    switch (Id)
    {
        case 78675: // Solar Beam
        case 80964:
        case 93985:
        case 97547: // Solar Beam
        case 106839: // Skull Bash
        case 147362: // Counter Shot
            return true;
    default:
        break;
    }
    if (HasEffect(SPELL_EFFECT_INTERRUPT_CAST) || HasAura(SPELL_AURA_MOD_SILENCE))
        return true;
    return false;
}

bool SpellInfo::IsNeedToCheckSchoolImmune() const
{
    // there are a problem with some of spells that does holypower or break cc kinda pvp trinket
    // so we need hack-handle for em

    switch (Id)
    {
        /*case 879:   ///< Exorcism         ///< Need more research on this ones, should not bypassing Ice block, Divine shield etc...
        case 24275: ///< Hammer of Wrath
        case 158392: ///< Hammer of Wrath
        case 35395: ///< Crusader Strike
        case 25912: ///< Holy Shock damage*/
        case 25914: ///< Holy Shock heal
        case 42292: ///< Pvp Trinket
        case 59752: ///< Every Man for Himself (racical)
        case 82327: ///< Holy Radiance
            return false;
        default:
            break;
    }

    return true;
}

bool SpellInfo::IsRemoveLossControlEffects() const
{
    switch (Id)
    {
        case 42292: // Pvp Trinket
        case 59752: // Every Man for Himself (racical)
        case 108201:// Desecrated Ground
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsRemoveFear() const
{
    if (HasAttribute(SPELL_ATTR5_USABLE_WHILE_FEARED))
        return true;

    switch (Id)
    {
        case 108201:  ///< Desecrated Ground
        case 118009:  ///< Desecrated Ground
        case 642:     ///< Divine Shield
        case 45438:   ///< Ice Block
        case 18499:   ///< Berserker Rage
        case 7744:    ///< Will of the Forsaken
        case 49039:   ///< Lichborne
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::DoesIgnoreGlobalCooldown(Unit* caster) const
{
    switch (Id)
    {
        case 5019:
            return true;
        break;
        case 85673: // Word of Glory
        case 114163:// Eternal Flame
        case 136494:// Word of Glory (other)
            if (caster->HasAura(53592)) // Guarded by the Light
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsAffectedByResilience() const
{
    return !HasCustomAttribute(SPELL_ATTR0_CU_TRIGGERED_IGNORE_RESILENCE);
}

bool SpellInfo::IsLethalPoison() const
{
    switch (Id)
    {
        case 112961:// Leeching Poison
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::CanTriggerHotStreak() const
{
    switch (Id)
    {
        case 133:   // Fireball
        case 2136:  // Fire Blast
        case 2948:  // Scorch
        case 11129: // Combustion
        case 11366: // Pyroblast
        case 30455: // Ice Lance
        case 44614: // Frostfire Bolt
        case 108853:// Inferno Blast
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::CannotBeAddedToCharm() const
{
    switch (Id)
    {
        case 121087: ///< Ground Slam
        case 121224: ///< Spirit Bolt
        case 123995: ///< Invoke Xuen, the White Tiger
        case 123996: ///< Crackling Tiger Lightning
        case 123999: ///< Crackling Tiger Lightning Driver
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsCustomArchaeologySpell() const
{
    switch (Id)
    {
        case 139776: // Banner of the Mantid Empire
        case 139779: // Ancient Sap Feeder
        case 139780: // The Praying Mantid
        case 139781: // Inert Sound Beacon
        case 139782: // Remains of a Paragon
        case 139783: // Mantid Lamp
        case 139784: // Pollen Collector
        case 139785: // Kypari Sap Container
        case 139786: // Mantid Sky Reaver
        case 139787: // Sonic Pulse Generator
            return true;
        default:
            return false;
    }

    return false;
}

Classes SpellInfo::GetClassIDBySpellFamilyName() const
{
    switch (SpellFamilyName)
    {
        case SPELLFAMILY_MAGE:
            return CLASS_MAGE;
        case SPELLFAMILY_WARRIOR:
            return CLASS_WARRIOR;
        case SPELLFAMILY_WARLOCK:
            return CLASS_WARLOCK;
        case SPELLFAMILY_PRIEST:
            return CLASS_PRIEST;
        case SPELLFAMILY_DRUID:
            return CLASS_DRUID;
        case SPELLFAMILY_ROGUE:
            return CLASS_ROGUE;
        case SPELLFAMILY_HUNTER:
            return CLASS_HUNTER;
        case SPELLFAMILY_PALADIN:
            return CLASS_PALADIN;
        case SPELLFAMILY_SHAMAN:
            return CLASS_SHAMAN;
        case SPELLFAMILY_DEATHKNIGHT:
            return CLASS_DEATH_KNIGHT;
        case SPELLFAMILY_MONK:
            return CLASS_MONK;
        default:
            return CLASS_NONE;
    }
}

std::string SpellInfo::GetNameForLogging() const
{
    std::ostringstream l_StringStream;

    if (SpellName && strlen(SpellName))
        l_StringStream << "\"" << SpellName << "\"" << "[" << Id << "]";
    else
        l_StringStream << "[" << Id << "]";

    return l_StringStream.str();
}

void SpellInfo::UpdateSpellEffectCount()
{
    EffectCount = 0;
    for (uint8 l_I = 0; l_I < SpellEffIndex::MAX_EFFECTS; ++l_I)
    {
        if (Effects[l_I].IsEffect())
            EffectCount = l_I + 1;
    }
}

bool SpellInfo::IsAffectedByWodAuraSystem() const
{
    switch (Id)
    {
        case 158831: ///< Devouring Plague DOT
        case 124280: ///< Touch of Karma
        case 114635: ///< Ember Tap
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsAuraNeedDynamicCalculation() const
{
    switch (Id)
    {
        case 1079:   ///< Rip
        case 1943:   ///< Rupture
        case 73651:  ///< Recuperate
        case 113344: ///< Bloodbath (DOT)
        case 114916: ///< Stay of Execution (damage)
        case 114917: ///< Stay of Execution (heal)
        case 154953: ///< Internal Bleeding
        case 155722: ///< Rake
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsAuraNeedPandemicEffect() const
{
    switch (Id)
    {
        case 5171:   ///< Slice and Dice
        case 84617:  ///< Revealing Strike
        case 125359: ///< Tiger Power
            return true;
        default:
            return false;
    }

    return false;
}
