/*
 * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
 * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "Common.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "Opcodes.h"
#include "Log.h"
#include "ObjectMgr.h"
#include "Player.h"
#include "Item.h"
#include "UpdateData.h"
#include "ObjectAccessor.h"
#include "SpellInfo.h"
#include "GuildMgr.h"
#include <vector>

void WorldSession::HandleSplitItemOpcode(WorldPacket& recvData)
{
    //sLog->outDebug(LOG_FILTER_PACKETIO, "WORLD: CMSG_SPLIT_ITEM");
    uint8 srcbag, srcslot, dstbag, dstslot;
    uint32 count;

    recvData >> count >> srcslot >> dstslot >> srcbag >> dstbag;
    //sLog->outDebug("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u, count = %u", srcbag, srcslot, dstbag, dstslot, count);

    uint16 src = ((srcbag << 8) | srcslot);
    uint16 dst = ((dstbag << 8) | dstslot);

    if (src == dst)
        return;

    if (count == 0)
        return;                                             //check count - if zero it's fake packet

    if (!m_Player->IsValidPos(srcbag, srcslot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!m_Player->IsValidPos(dstbag, dstslot, false))       // can be autostore pos
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    m_Player->SplitItem(src, dst, count);
}

void WorldSession::HandleSwapInvItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_Slot1;
    uint8 l_Slot2;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_Slot2 >> l_Slot1;

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (l_Slot1 == l_Slot2)
        return;

    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot1, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot2, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    uint16 l_Src    = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot1);
    uint16 l_Dest   = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot2);

    m_Player->SwapItem(l_Src, l_Dest);
}

void WorldSession::HandleAutoEquipItemSlotOpcode(WorldPacket& recvData)
{
    ObjectGuid itemGuid;
    uint8 dstslot;

    recvData >> dstslot;

    itemGuid[3] = recvData.ReadBit();
    itemGuid[2] = recvData.ReadBit();
    itemGuid[1] = recvData.ReadBit();
    uint8 itemCount = recvData.ReadBits(2);
    itemGuid[4] = recvData.ReadBit();

    std::vector<bool> hasBag(itemCount, false);
    std::vector<bool> hasSlot(itemCount, false);

    for (uint8 i = 0; i < itemCount; ++i)
    {
        hasBag[i] = !recvData.ReadBit();
        hasSlot[i] = !recvData.ReadBit();
    }

    itemGuid[6] = recvData.ReadBit();
    itemGuid[0] = recvData.ReadBit();
    itemGuid[5] = recvData.ReadBit();
    itemGuid[7] = recvData.ReadBit();

    recvData.FlushBits();

    uint8 bytes[8] = { 0, 3, 6, 2, 5, 7, 1, 4 };
    recvData.ReadBytesSeq(itemGuid, bytes);

    std::vector<uint8> inventoryBags(itemCount, 0);
    std::vector<uint8> inventorySlots(itemCount, 0);
    for (uint8 i = 0; i < itemCount; ++i)
    {
        if (hasSlot[i])
            recvData >> inventorySlots[i];
        if (hasBag[i])
            recvData >> inventoryBags[i];
    }

    // cheating attempt, client should never send opcode in that case
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, dstslot))
        return;

    Item* item = m_Player->GetItemByGuid(itemGuid);
    uint16 dstpos = dstslot | (INVENTORY_SLOT_BAG_0 << 8);

    if (!item || item->GetPos() == dstpos)
        return;

    m_Player->SwapItem(item->GetPos(), dstpos);
}

void WorldSession::HandleSwapItem(WorldPacket& recvData)
{
    //sLog->outDebug(LOG_FILTER_PACKETIO, "WORLD: CMSG_SWAP_ITEM");
    uint8 dstbag, dstslot, srcbag, srcslot;

    recvData >> srcslot >> dstbag >> dstslot >> srcbag;
    //sLog->outDebug("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u", srcbag, srcslot, dstbag, dstslot);

    uint16 src = ((srcbag << 8) | srcslot);
    uint16 dst = ((dstbag << 8) | dstslot);

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (src == dst)
        return;

    if (!m_Player->IsValidPos(srcbag, srcslot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!m_Player->IsValidPos(dstbag, dstslot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    sLog->outAshran("HandleSwapItem[%u] %u %u", m_Player->GetGUIDLow(), src, dst);
    m_Player->SwapItem(src, dst);
}

void WorldSession::HandleAutoEquipItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_PackSlot;
    p_RecvData >> l_Slot;

    Item* l_SrcItem  = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_SrcItem)
        return;                                             // only at cheat

    uint16 l_Dest;

    InventoryResult l_Msg = m_Player->CanEquipItem(NULL_SLOT, l_Dest, l_SrcItem, !l_SrcItem->IsBag());

    if (l_Msg != EQUIP_ERR_OK)
    {
        m_Player->SendEquipError(l_Msg, l_SrcItem, NULL);
        return;
    }

    uint16 l_Src = l_SrcItem->GetPos();

    // prevent equip in same slot, only at cheat
    if (l_Dest == l_Src)
        return;

    Item* l_DestItem = m_Player->GetItemByPos(l_Dest);

    // empty slot, simple case
    if (!l_DestItem)
    {
        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->EquipItem(l_Dest, l_SrcItem, true);

        m_Player->AutoUnequipOffhandIfNeed();
    }
    // have currently equipped item, not simple case
    else
    {
        uint8 l_DestBag = l_DestItem->GetBagSlot();
        uint8 l_DestSlot = l_DestItem->GetSlot();

        l_Msg = m_Player->CanUnequipItem(l_Dest, !l_SrcItem->IsBag());

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_DestItem, NULL);
            return;
        }

        // check dest->src move possibility
        ItemPosCountVec l_SSrc;
        uint16 l_ESrc = 0;

        if (m_Player->IsInventoryPos(l_Src))
        {
            l_Msg = m_Player->CanStoreItem(l_PackSlot, l_Slot, l_SSrc, l_DestItem, true);

            if (l_Msg != EQUIP_ERR_OK)
                l_Msg = m_Player->CanStoreItem(l_PackSlot, NULL_SLOT, l_SSrc, l_DestItem, true);

            if (l_Msg != EQUIP_ERR_OK)
                l_Msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, l_SSrc, l_DestItem, true);
        }
        else if (m_Player->IsBankPos(l_Src))
        {
            l_Msg = m_Player->CanBankItem(l_PackSlot, l_Slot, l_SSrc, l_DestItem, true);

            if (l_Msg != EQUIP_ERR_OK)
                l_Msg = m_Player->CanBankItem(l_PackSlot, NULL_SLOT, l_SSrc, l_DestItem, true);

            if (l_Msg != EQUIP_ERR_OK)
                l_Msg = m_Player->CanBankItem(NULL_BAG, NULL_SLOT, l_SSrc, l_DestItem, true);
        }
        else if (m_Player->IsEquipmentPos(l_Src))
        {
            l_Msg = m_Player->CanEquipItem(l_Slot, l_ESrc, l_DestItem, true);

            if (l_Msg == EQUIP_ERR_OK)
                l_Msg = m_Player->CanUnequipItem(l_ESrc, true);
        }

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_DestItem, l_SrcItem);
            return;
        }

        // now do moves, remove...
        m_Player->RemoveItem(l_DestBag, l_DestSlot, false);
        m_Player->RemoveItem(l_PackSlot, l_Slot, false);

        // add to dest
        m_Player->EquipItem(l_Dest, l_SrcItem, true);

        // add to src
        if (m_Player->IsInventoryPos(l_Src))
            m_Player->StoreItem(l_SSrc, l_DestItem, true);
        else if (m_Player->IsBankPos(l_Src))
            m_Player->BankItem(l_SSrc, l_DestItem, true);
        else if (m_Player->IsEquipmentPos(l_Src))
            m_Player->EquipItem(l_ESrc, l_DestItem, true);

        m_Player->AutoUnequipOffhandIfNeed();
    }
}

void WorldSession::HandleDestroyItemOpcode(WorldPacket & p_Packet)
{
    /// sLog->outDebug(LOG_FILTER_PACKETIO, "WORLD: CMSG_DESTROY_ITEM");
    uint32 l_Count          = 0;
    uint8  l_ContainerId    = 0;
    uint8  l_SlotNum        = 0;

    p_Packet >> l_Count;
    p_Packet >> l_ContainerId;
    p_Packet >> l_SlotNum;

    uint16 l_ItemPosition = (l_ContainerId << 8) | l_SlotNum;

    /// prevent drop unequipable items (in combat, for example) and non-empty bags
    if (m_Player->IsEquipmentPos(l_ItemPosition) || m_Player->IsBagPos(l_ItemPosition))
    {
        InventoryResult msg = m_Player->CanUnequipItem(l_ItemPosition, false);
        if (msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(msg, m_Player->GetItemByPos(l_ItemPosition), NULL);
            return;
        }
    }

    Item* l_Item  = m_Player->GetItemByPos(l_ContainerId, l_SlotNum);

    if (!l_Item)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (l_Item->GetTemplate()->Flags & ITEM_PROTO_FLAG_INDESTRUCTIBLE)
    {
        m_Player->SendEquipError(EQUIP_ERR_DROP_BOUND_ITEM, NULL, NULL);
        return;
    }

    /// If trading
    if (TradeData * l_TradeData = m_Player->GetTradeData())
    {
        /// If current item is in trade window (only possible with packet spoofing - silent return)
        if (l_TradeData->GetTradeSlotForItem(l_Item->GetGUID()) != TRADE_SLOT_INVALID)
        {
            m_Player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, NULL, NULL);
            return;
        }
    }

    sLog->outAshran("HandleDestroyItemOpcode[%u] %u %u", m_Player->GetGUIDLow(), l_ItemPosition, l_Count);

    if (l_Count)
    {
        uint32 i_count = l_Count;
        m_Player->DestroyItemCount(l_Item, i_count, true);
    }
    else
        m_Player->DestroyItem(l_ContainerId, l_SlotNum, true);
}

void WorldSession::SendItemDb2Reply(uint32 entry)
{
    WorldPacket data(SMSG_DB_REPLY, 44);
    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry);
    if (!proto)
    {
        data << uint32(DB2_REPLY_ITEM);
        data << uint32(-1);         // entry
        data << uint32(time(NULL)); // hotfix date
        data << uint32(0);          // size of next block
        return;
    }

    ByteBuffer buff;
    buff << uint32(entry);
    buff << uint32(proto->Class);
    buff << uint32(proto->SubClass);
    buff << int32(proto->SoundOverrideSubclass);
    buff << uint32(proto->Material);
    buff << uint32(proto->DisplayInfoID);
    buff << uint32(proto->InventoryType);
    buff << uint32(proto->Sheath);

    data << uint32(DB2_REPLY_ITEM);
    data << uint32(entry);
    data << uint32(sObjectMgr->GetHotfixDate(entry, DB2_REPLY_ITEM));
    data << uint32(buff.size());
    data.append(buff);

    SendPacket(&data);
}

void WorldSession::SendItemSparseDb2Reply(uint32 entry)
{
    WorldPacket data(SMSG_DB_REPLY, 526);
    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry);
    if (!proto)
    {
        data << uint32(DB2_REPLY_SPARSE);
        data << uint32(-1);         // entry
        data << uint32(time(NULL)); // hotfix date
        data << uint32(0);          // size of next block
        return;
    }

    ByteBuffer buff;
    buff << uint32(entry);
    buff << uint32(proto->Quality);
    buff << uint32(proto->Flags);
    buff << uint32(proto->Flags2);
    buff << uint32(proto->Flags3);
    buff << float(proto->Unk430_1);
    buff << float(proto->Unk430_2);
    buff << uint32(proto->BuyCount);
    buff << int32(proto->BuyPrice);
    buff << uint32(proto->SellPrice);
    buff << uint32(proto->InventoryType);
    buff << int32(proto->AllowableClass);
    buff << int32(proto->AllowableRace);
    buff << uint32(proto->ItemLevel);
    buff << uint32(proto->RequiredLevel);
    buff << uint32(proto->RequiredSkill);
    buff << uint32(proto->RequiredSkillRank);
    buff << uint32(proto->RequiredSpell);
    buff << uint32(proto->RequiredHonorRank);
    buff << uint32(proto->RequiredCityRank);
    buff << uint32(proto->RequiredReputationFaction);
    buff << uint32(proto->RequiredReputationRank);
    buff << int32(proto->MaxCount);
    buff << int32(proto->Stackable);
    buff << uint32(proto->ContainerSlots);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buff << uint32(proto->ItemStat[x].ItemStatType);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buff << int32(proto->ItemStat[x].ItemStatValue);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buff << int32(proto->ItemStat[x].ScalingValue);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buff << int32(proto->ItemStat[x].SocketCostRate);

    buff << uint32(proto->ScalingStatDistribution);
    buff << uint32(proto->DamageType);
    buff << uint32(proto->Delay);
    buff << float(proto->RangedModRange);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << int32(proto->Spells[x].SpellId);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << uint32(proto->Spells[x].SpellTrigger);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << int32(proto->Spells[x].SpellCharges);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << int32(proto->Spells[x].SpellCooldown);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << uint32(proto->Spells[x].SpellCategory);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buff << int32(proto->Spells[x].SpellCategoryCooldown);

    buff << uint32(proto->Bonding);

    // item name
    std::string name = proto->Name1;
    buff << uint16(name.length());
    if (name.length())
        buff << name;

    for (uint32 i = 0; i < 3; ++i) // other 3 names
        buff << uint16(0);

    std::string desc = proto->Description;
    buff << uint16(desc.length());
    if (desc.length())
        buff << desc;

    buff << uint32(proto->PageText);
    buff << uint32(proto->LanguageID);
    buff << uint32(proto->PageMaterial);
    buff << uint32(proto->StartQuest);
    buff << uint32(proto->LockID);
    buff << int32(proto->Material);
    buff << uint32(proto->Sheath);
    buff << int32(proto->RandomProperty);
    buff << int32(proto->RandomSuffix);
    buff << uint32(proto->ItemSet);

    buff << uint32(proto->Area);
    buff << uint32(proto->Map);
    buff << uint32(proto->BagFamily);
    buff << uint32(proto->TotemCategory);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SOCKETS; ++x)
        buff << uint32(proto->Socket[x].Color);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SOCKETS; ++x)
        buff << uint32(proto->Socket[x].Content);

    buff << uint32(proto->socketBonus);
    buff << uint32(proto->GemProperties);
    buff << float(proto->ArmorDamageModifier);
    buff << int32(proto->Duration);
    buff << uint32(proto->ItemLimitCategory);
    buff << uint32(proto->HolidayId);
    buff << float(proto->StatScalingFactor);    // StatScalingFactor
    buff << uint32(proto->CurrencySubstitutionId);
    buff << uint32(proto->CurrencySubstitutionCount);

    data << uint32(DB2_REPLY_SPARSE);
    data << uint32(entry);
    data << uint32(sObjectMgr->GetHotfixDate(entry, DB2_REPLY_SPARSE));
    data << uint32(buff.size());
    data.append(buff);

    SendPacket(&data);
}

void WorldSession::HandleReadItem(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_READ_ITEM");

    uint8 bag, slot;
    recvData >> bag >> slot;

    Item* pItem = m_Player->GetItemByPos(bag, slot);
    if (pItem && pItem->GetTemplate()->PageText)
    {
        WorldPacket data;

        InventoryResult msg = m_Player->CanUseItem(pItem);
        if (msg == EQUIP_ERR_OK)
        {
            data.Initialize(SMSG_READ_ITEM_OK, 8);
            sLog->outInfo(LOG_FILTER_NETWORKIO, "STORAGE: Item page sent");
        }
        else
        {
            data.Initialize(SMSG_READ_ITEM_FAILED, 8);
            sLog->outInfo(LOG_FILTER_NETWORKIO, "STORAGE: Unable to read item");
            m_Player->SendEquipError(msg, pItem, NULL);
        }

        data << pItem->GetGUID();
        SendPacket(&data);
    }
    else
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
}

void WorldSession::HandleSellItemOpcode(WorldPacket& p_RecvPacket)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_SELL_ITEM");

    time_t l_Now = time(NULL);

    if (l_Now - l_TimeLastSellItemOpcode < 1)
        return;
    else
       l_TimeLastSellItemOpcode = l_Now;

    uint64 l_VendorGUID = 0;
    uint64 l_ItemGUID   = 0;

    uint32 l_Amount = 0;

    p_RecvPacket.readPackGUID(l_VendorGUID);
    p_RecvPacket.readPackGUID(l_ItemGUID);

    p_RecvPacket >> l_Amount;

    if (!l_ItemGUID)
        return;

    Creature* l_Creature = GetPlayer()->GetNPCIfCanInteractWith(l_VendorGUID, UNIT_NPC_FLAG_VENDOR);

    if (!l_Creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleSellItemOpcode - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(l_VendorGUID)));
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, l_ItemGUID);
        return;
    }

    /// remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* l_PlayerItem = m_Player->GetItemByGuid(l_ItemGUID);

    if (l_PlayerItem)
    {
        sLog->outAshran("HandleSellItemOpcode[%u] %u %u", GetPlayer()->GetGUIDLow(), l_PlayerItem->GetEntry(), l_Amount);

        // prevent sell not owner item
        if (m_Player->GetGUID() != l_PlayerItem->GetOwnerGUID())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent sell non empty bag by drag-and-drop at vendor's item list
        if (l_PlayerItem->IsNotEmptyBag())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent sell currently looted item
        if (m_Player->GetLootGUID() == l_PlayerItem->GetGUID())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent selling item for sellprice when the item is still refundable
        // this probably happens when right clicking a refundable item, the client sends both
        // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
        if (l_PlayerItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
            return; // Therefore, no feedback to client

        // special case at auto sell (sell all)
        if (l_Amount == 0)
            l_Amount = l_PlayerItem->GetCount();
        else
        {
            // prevent sell more items that exist in stack (possible only not from client)
            if (l_Amount > l_PlayerItem->GetCount())
            {
                m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                return;
            }
        }

        ItemTemplate const* l_PlayerItemTemplate = l_PlayerItem->GetTemplate();

        if (l_PlayerItemTemplate)
        {
            if (l_PlayerItemTemplate->SellPrice > 0)
            {
                if (l_Amount < l_PlayerItem->GetCount())               // need split items
                {
                    Item* pNewItem = l_PlayerItem->CloneItem(l_Amount, m_Player);

                    if (!pNewItem)
                    {
                        sLog->outError(LOG_FILTER_NETWORKIO, "WORLD: HandleSellItemOpcode - could not create clone of item %u; count = %u", l_PlayerItem->GetEntry(), l_Amount);
                        m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                        return;
                    }

                    l_PlayerItem->SetCount(l_PlayerItem->GetCount() - l_Amount);
                    m_Player->ItemRemovedQuestCheck(l_PlayerItem->GetEntry(), l_Amount);

                    if (m_Player->IsInWorld())
                        l_PlayerItem->SendUpdateToPlayer(m_Player);

                    l_PlayerItem->SetState(ITEM_CHANGED, m_Player);

                    m_Player->AddItemToBuyBackSlot(pNewItem);

                    if (m_Player->IsInWorld())
                        pNewItem->SendUpdateToPlayer(m_Player);
                }
                else
                {
                    m_Player->ItemRemovedQuestCheck(l_PlayerItem->GetEntry(), l_PlayerItem->GetCount());
                    m_Player->RemoveItem(l_PlayerItem->GetBagSlot(), l_PlayerItem->GetSlot(), true);

                    l_PlayerItem->RemoveFromUpdateQueueOf(m_Player);

                    m_Player->AddItemToBuyBackSlot(l_PlayerItem);
                }

                uint32 l_Money = l_PlayerItemTemplate->SellPrice * l_Amount;

                m_Player->ModifyMoney(l_Money);
                m_Player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_VENDORS, l_Money);
            }
            else
                m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);

            return;
        }
    }

    m_Player->SendSellError(SELL_ERR_CANT_FIND_ITEM, l_Creature, l_ItemGUID);

    return;
}

void WorldSession::HandleBuybackItem(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_BUYBACK_ITEM");
    uint64 vendorguid;
    uint32 slot;

    recvData.readPackGUID(vendorguid);
    recvData >> slot;

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleBuybackItem - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorguid)));
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = m_Player->GetItemFromBuyBackSlot(slot);
    if (pItem)
    {
        sLog->outAshran("HandleBuybackItem[%u] %u %u", m_Player->GetGUIDLow(), pItem->GetEntry(), slot);
        uint32 price = m_Player->GetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + slot - BUYBACK_SLOT_START);
        if (!m_Player->HasEnoughMoney(uint64(price)))
        {
            m_Player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, pItem->GetEntry(), 0);
            return;
        }

        ItemPosCountVec dest;
        InventoryResult msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg == EQUIP_ERR_OK)
        {
            m_Player->ModifyMoney(-(int32)price);
            m_Player->RemoveItemFromBuyBackSlot(slot, false);
            m_Player->ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
            m_Player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());
            m_Player->StoreItem(dest, pItem, true);
        }
        else
            m_Player->SendEquipError(msg, pItem, NULL);
        return;
    }
    else
        m_Player->SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, 0, 0);
}

void WorldSession::HandleBuyItemInSlotOpcode(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_BUY_ITEM_IN_SLOT");
    uint64 vendorguid, bagguid;
    uint32 item, slot, count;
    uint8 bagslot;

    recvData >> vendorguid >> item  >> slot >> bagguid >> bagslot >> count;

    // client expects count starting at 1, and we send vendorslot+1 to client already
    if (slot > 0)
        --slot;
    else
        return;                                             // cheating

    uint8 bag = NULL_BAG;                                   // init for case invalid bagGUID
    Item* bagItem = NULL;
    // find bag slot by bag guid
    if (bagguid == m_Player->GetGUID())
        bag = INVENTORY_SLOT_BAG_0;
    else
        bagItem = m_Player->GetItemByGuid(bagguid);

    if (bagItem && bagItem->IsBag())
        bag = bagItem->GetSlot();

    // bag not found, cheating?
    if (bag == NULL_BAG)
        return;

    sLog->outAshran("HandleBuyItemInSlotOpcode[%u] %u %u %u %u", m_Player->GetGUIDLow(), item, slot, count, bagslot);

    GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, bag, bagslot);
}

void WorldSession::HandleBuyItemOpcode(WorldPacket& p_RecvPacket)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_BUY_ITEM");

    uint64 l_VendorGUID = 0;
    uint64 l_BagGUID    = 0;

    uint32 l_Muid       = 0;
    uint32 l_Slot       = 0;
    uint32 l_Quantity   = 0;
    uint32 l_ItemID     = 0;

    uint8 l_ItemType = ITEM_VENDOR_TYPE_NONE;

    p_RecvPacket.readPackGUID(l_VendorGUID);
    p_RecvPacket.readPackGUID(l_BagGUID);

    p_RecvPacket >> l_ItemID;
    p_RecvPacket.read_skip<uint32>();           ///< RandomPropertiesSeed
    p_RecvPacket.read_skip<uint32>();           ///< RandomPropertiesID

    bool l_HasItemBonus     = p_RecvPacket.ReadBit();
    bool l_HasModifications = p_RecvPacket.ReadBit();

    if (l_HasItemBonus)
    {
        p_RecvPacket.read_skip<uint8>();        ///< Context

        uint32 l_Count = p_RecvPacket.read<uint32>();

        for (uint32 l_I = 0; l_I < l_Count;  l_I++)
            p_RecvPacket.read_skip<uint32>();   ///< Bonus ID
    }

    if (l_HasModifications)
        p_RecvPacket.read_skip<uint32>();       ///< Modifications

    p_RecvPacket >> l_Quantity;
    p_RecvPacket >> l_Muid;
    p_RecvPacket >> l_Slot;

    l_ItemType = p_RecvPacket.ReadBits(2);

    /// Client expects count starting at 1, and we send vendorslot+1 to client already
    if (l_Muid > 0)
        --l_Muid;
    else
        return; // cheating

    sLog->outAshran("HandleBuyItemOpcode[%u] %u %u %u", m_Player->GetGUIDLow(), l_Quantity, l_Muid, l_Slot);

    switch (l_ItemType)
    {
        case ITEM_VENDOR_TYPE_ITEM:
            m_Player->BuyItemFromVendorSlot(l_VendorGUID, l_Muid, l_ItemID, l_Quantity, NULL_BAG, NULL_SLOT);
            break;

        case ITEM_VENDOR_TYPE_CURRENCY:
            m_Player->BuyCurrencyFromVendorSlot(l_VendorGUID, l_Muid, l_ItemID, l_Quantity);
            break;

        default:
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: received wrong itemType (%u) in HandleBuyItemOpcode", l_ItemType);
            break;
    }
}

void WorldSession::HandleListInventoryOpcode(WorldPacket& recvData)
{
    uint64 guid;

    recvData.readPackGUID(guid);

    if (!GetPlayer()->isAlive())
        return;

    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_LIST_INVENTORY");

    SendListInventory(guid);
}

void WorldSession::SendListInventory(uint64 p_VendorGUID)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_LIST_INVENTORY");

    Creature* l_Vendor = GetPlayer()->GetNPCIfCanInteractWith(p_VendorGUID, UNIT_NPC_FLAG_VENDOR);

    if (!l_Vendor)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: SendListInventory - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(p_VendorGUID)));
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    /// remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    /// Stop the npc if moving
    if (l_Vendor->HasUnitState(UNIT_STATE_MOVING))
        l_Vendor->StopMoving();

    VendorItemData const* vendorItems = l_Vendor->GetVendorItems();
    uint32 rawItemCount = vendorItems ? vendorItems->GetItemCount() : 0;

    ByteBuffer l_ItemDataBuffer;

    const float l_DiscountMod = m_Player->GetReputationPriceDiscount(l_Vendor);
    uint32 l_Muid = 0;
    uint32 l_ItemCount = 0;

    for (uint32 slot = 0; slot < rawItemCount; ++slot)
    {
        l_Muid++;

        VendorItem const* l_VendorItem = vendorItems->GetItem(slot);
        if (!l_VendorItem)
            continue;

        if (l_VendorItem->Type == ITEM_VENDOR_TYPE_ITEM)
        {
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_VendorItem->item);
            if (!l_ItemTemplate)
                continue;

            uint32 l_AvailableInStock = !l_VendorItem->maxcount ? 0xFFFFFFFF : l_Vendor->GetVendorItemCurrentCount(l_VendorItem);
            if (!m_Player->isGameMaster()) // ignore conditions if GM on
            {
                ConditionList conditions = sConditionMgr->GetConditionsForNpcVendorEvent(l_Vendor->GetEntry(), l_VendorItem->item);
                if (!sConditionMgr->IsObjectMeetToConditions(m_Player, l_Vendor, conditions))
                {
                    sLog->outDebug(LOG_FILTER_CONDITIONSYS, "SendListInventory: conditions not met for creature entry %u item %u", l_Vendor->GetEntry(), l_VendorItem->item);
                    continue;
                }

                // Respect allowed class
                if (!(l_ItemTemplate->AllowableClass & m_Player->getClassMask()) && l_ItemTemplate->Bonding == BIND_WHEN_PICKED_UP)
                    continue;

                // Custom MoP Script for Pandarens Mounts (Alliance)
                if (l_ItemTemplate->Class == 15 && l_ItemTemplate->SubClass == 5 && m_Player->getRace() != RACE_PANDAREN_ALLI
                    && m_Player->getRace() != RACE_PANDAREN_HORDE && m_Player->getRace() != RACE_PANDAREN_NEUTRAL
                    && l_Vendor->GetEntry() == 65068 && m_Player->GetReputationRank(1353) != REP_EXALTED)
                    continue;

                // Custom MoP Script for Pandarens Mounts (Horde)
                if (l_ItemTemplate->Class == 15 && l_ItemTemplate->SubClass == 5 && m_Player->getRace() != RACE_PANDAREN_ALLI
                    && m_Player->getRace() != RACE_PANDAREN_HORDE && m_Player->getRace() != RACE_PANDAREN_NEUTRAL
                    && l_Vendor->GetEntry() == 66022 && m_Player->GetReputationRank(1352) != REP_EXALTED)
                    continue;

                // Only display items in vendor lists for the team the player is on
                if ((l_ItemTemplate->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && m_Player->GetTeam() == ALLIANCE) ||
                    (l_ItemTemplate->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && m_Player->GetTeam() == HORDE))
                    continue;

                std::vector<GuildReward> const& rewards = sGuildMgr->GetGuildRewards();
                bool guildRewardCheckPassed = true;

                for (auto reward: rewards)
                {
                    if (l_ItemTemplate->ItemId != reward.Entry)
                        continue;

                    Guild* guild = sGuildMgr->GetGuildById(m_Player->GetGuildId());

                    if (!guild)
                    {
                        guildRewardCheckPassed = false;
                        break;
                    }

                    if (reward.Standing)
                        if (m_Player->GetReputationRank(REP_GUILD) < reward.Standing)
                        {
                            guildRewardCheckPassed = false;
                            break;
                        }

                    if (reward.AchievementId)
                        if (!guild->GetAchievementMgr().HasAchieved(reward.AchievementId))
                        {
                            if (!(reward.AchievementId == 5492 && guild->GetAchievementMgr().HasAchieved(4912)) && !(reward.AchievementId == 4912 && guild->GetAchievementMgr().HasAchieved(5492)))
                            {
                                guildRewardCheckPassed = false;
                                break;
                            }
                        }

                    if (reward.Racemask)
                        if (!(m_Player->getRaceMask() & reward.Racemask))
                        {
                            guildRewardCheckPassed = false;
                            break;
                        }
                }

                if (!guildRewardCheckPassed)
                    continue;

                // Items sold out are not displayed in list
                if (l_AvailableInStock == 0)
                    continue;
            }

            // reputation discount
            int32 l_Price = l_VendorItem->IsGoldRequired(l_ItemTemplate) ? uint32(floor(l_ItemTemplate->BuyPrice * l_DiscountMod)) : 0;

            if (int32 l_PriceMod = m_Player->GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES))
                 l_Price -= CalculatePct(l_Price, l_PriceMod);

            l_ItemDataBuffer << uint32(l_Muid);
            l_ItemDataBuffer << uint32(ITEM_VENDOR_TYPE_ITEM);              ///< Item type

            l_ItemDataBuffer << uint32(l_VendorItem->item);                 ///< Item Entry
            l_ItemDataBuffer << uint32(l_ItemTemplate->RandomProperty);     ///< Random Properties Seed
            l_ItemDataBuffer << uint32(l_ItemTemplate->RandomSuffix);       ///< Random Properties ID

            l_ItemDataBuffer.WriteBit(false);                               ///< Has Item Bonus
            l_ItemDataBuffer.WriteBit(false);                               ///< Has Modifications
            l_ItemDataBuffer.FlushBits();

            l_ItemDataBuffer << int32(l_AvailableInStock);                  ///< Available In Stock
            l_ItemDataBuffer << uint32(l_Price);                            ///< Price
            l_ItemDataBuffer << uint32(l_ItemTemplate->MaxDurability);      ///< Max durability
            l_ItemDataBuffer << uint32(l_ItemTemplate->BuyCount);           ///< Stack count
            l_ItemDataBuffer << uint32(l_VendorItem->ExtendedCost);         ///< Extended cost ID
            l_ItemDataBuffer << uint32(0);                                  ///< Player condition failed

            l_ItemDataBuffer.WriteBit(true);                                ///< Do not filter on vendor
            l_ItemDataBuffer.FlushBits();

            l_ItemCount++;
        }
        else if (l_VendorItem->Type == ITEM_VENDOR_TYPE_CURRENCY)
        {
            CurrencyTypesEntry const* currencyTemplate = sCurrencyTypesStore.LookupEntry(l_VendorItem->item);

            if (!currencyTemplate)
                continue;

            if (l_VendorItem->ExtendedCost == 0)
                continue; // there's no price defined for currencies, only extendedcost is used

            uint32 l_Precision  = (currencyTemplate->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
            uint32 l_Price      = l_VendorItem->maxcount * l_Precision;

            l_ItemDataBuffer << uint32(l_Muid);
            l_ItemDataBuffer << uint32(ITEM_VENDOR_TYPE_CURRENCY);          ///< Item type

            l_ItemDataBuffer << uint32(l_VendorItem->item);                 ///< Item Entry
            l_ItemDataBuffer << uint32(0);                                  ///< Random Properties Seed
            l_ItemDataBuffer << uint32(0);                                  ///< Random Properties ID

            l_ItemDataBuffer.WriteBit(false);                               ///< Has Item Bonus
            l_ItemDataBuffer.WriteBit(false);                               ///< Has Modifications
            l_ItemDataBuffer.FlushBits();

            l_ItemDataBuffer << int32(-1);                                  ///< Available In Stock
            l_ItemDataBuffer << uint32(l_Price);                            ///< Price
            l_ItemDataBuffer << uint32(0);                                  ///< Max durability
            l_ItemDataBuffer << uint32(0);                                  ///< Stack count
            l_ItemDataBuffer << uint32(0);                                  ///< Extended cost ID
            l_ItemDataBuffer << uint32(0);                                  ///< Player condition failed

            l_ItemDataBuffer.WriteBit(true);                                ///< Do not filter on vendor
            l_ItemDataBuffer.FlushBits();

            l_ItemCount++;
        }
        // else error
    }

    WorldPacket l_Response(SMSG_LIST_INVENTORY);
    l_Response.appendPackGUID(p_VendorGUID);

    if (l_ItemCount)
        l_Response << uint8(l_ItemCount);                   ///< Reason
    else
        l_Response << uint8(l_Vendor->isArmorer());         ///< Reason

    l_Response << uint32(l_ItemCount);
    l_Response.append(l_ItemDataBuffer);

    SendPacket(&l_Response);
}

void WorldSession::HandleAutoStoreBagItemOpcode(WorldPacket& recvData)
{
    uint8 srcbag, srcslot, dstbag;

    recvData >> dstbag >> srcbag >> srcslot;

    uint8 unkCounter = recvData.ReadBits(2);

    for (uint8 i = 0; i < unkCounter; i++)
    {
        recvData.ReadBit();
        recvData.ReadBit();
    }

    recvData.FlushBits();

    for (uint8 i = 0; i < unkCounter; i++)
    {
        recvData.read_skip<uint8>();
        recvData.read_skip<uint8>();
    }

    Item* pItem = m_Player->GetItemByPos(srcbag, srcslot);
    if (!pItem)
        return;

    if (!m_Player->IsValidPos(dstbag, NULL_SLOT, false))      // can be autostore pos
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    uint16 src = pItem->GetPos();

    // check unequip potability for equipped items and bank bags
    if (m_Player->IsEquipmentPos (src) || m_Player->IsBagPos (src))
    {
        InventoryResult msg = m_Player->CanUnequipItem(src, !m_Player->IsBagPos (src));
        if (msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(msg, pItem, NULL);
            return;
        }
    }

    ItemPosCountVec dest;
    InventoryResult msg = m_Player->CanStoreItem(dstbag, NULL_SLOT, dest, pItem, false);
    if (msg != EQUIP_ERR_OK)
    {
        m_Player->SendEquipError(msg, pItem, NULL);
        return;
    }

    // no-op: placed in same slot
    if (dest.size() == 1 && dest[0].pos == src)
    {
        // just remove grey item state
        m_Player->SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, pItem, NULL);
        return;
    }

    sLog->outAshran("HandleAutoStoreBagItemOpcode[%u] %u %u %u", m_Player->GetGUIDLow(), dstbag, srcbag, srcslot);

    m_Player->RemoveItem(srcbag, srcslot, true);
    m_Player->StoreItem(dest, pItem, true);
}

void WorldSession::HandleBuyBankSlotOpcode(WorldPacket& p_RecvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BUY_BANK_SLOT");

    uint64 l_BankerGUID;

    p_RecvData.readPackGUID(l_BankerGUID);

    uint32 l_Slot = m_Player->GetBankBagSlotCount();

    // next slot
    ++l_Slot;

    sLog->outInfo(LOG_FILTER_NETWORKIO, "PLAYER: Buy bank bag slot, slot number = %u", l_Slot);

    BankBagSlotPricesEntry const* l_SlotEntry = sBankBagSlotPricesStore.LookupEntry(l_Slot);

    if (!l_SlotEntry)
        return;

    uint32 l_Price = l_SlotEntry->price;

    if (!m_Player->HasEnoughMoney(uint64(l_Price)))
        return;

    m_Player->SetBankBagSlotCount(l_Slot);
    m_Player->ModifyMoney(-int64(l_Price));

    m_Player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BUY_BANK_SLOT);
}

void WorldSession::HandleBuyReagentBankOpcode(WorldPacket& p_RecvData)
{
    uint64 l_BankerGUID;

    p_RecvData.readPackGUID(l_BankerGUID);

    if (m_Player->HasUnlockedReagentBank())
        return;

    Creature * l_Banker = m_Player->GetNPCIfCanInteractWith(l_BankerGUID, UNIT_NPC_FLAG_BANKER);

    if (!l_Banker)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleBuyReagentBankOpcode - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(l_BankerGUID));
        return;
    }

    uint64 l_RegentBankPrice = 1000000;

    if (!m_Player->HasEnoughMoney(uint64(l_RegentBankPrice)))
        return;

    m_Player->ModifyMoney(-int64(l_RegentBankPrice));
    m_Player->UnlockReagentBank();
}

void WorldSession::HandleSortReagentBankBagsOpcode(WorldPacket& p_RecvData)
{
    if (!m_Player->HasUnlockedReagentBank())
        return;

    /// TODO
}

void WorldSession::HandleAutoBankItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_Slot;
    p_RecvData >> l_PackSlot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_Item)
        return;

    ItemPosCountVec l_Dest;
    InventoryResult l_Msg = m_Player->CanBankItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);

    if (l_Msg != EQUIP_ERR_OK)
    {
        m_Player->SendEquipError(l_Msg, l_Item, NULL);
        return;
    }

    if (l_Dest.size() == 1 && l_Dest[0].pos == l_Item->GetPos())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_SWAP, l_Item, NULL);
        return;
    }

    m_Player->RemoveItem(l_PackSlot, l_Slot, true);
    m_Player->ItemRemovedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    m_Player->BankItem(l_Dest, l_Item, true);
}

void WorldSession::HandleAutoStoreBankItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_Slot;
    p_RecvData >> l_PackSlot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_Item)
        return;

    sLog->outAshran("HandleAutoStoreBankItemOpcode[%u] %u %u %u", m_Player->GetGUID(), l_PackSlot, l_Slot, l_Item->GetEntry());

    // moving from bank to inventory
    if (m_Player->IsBankPos(l_PackSlot, l_Slot))
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, NULL);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->StoreItem(l_Dest, l_Item, true);
        m_Player->ItemAddedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    }
    // moving from inventory to bank
    else
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanBankItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, NULL);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->BankItem(l_Dest, l_Item, true);
    }
}

void WorldSession::SendEnchantmentLog(uint64 Target, uint64 Caster, uint32 ItemID, uint32 enchantID, uint8 slotID)
{
    WorldPacket data(SMSG_ENCHANTMENT_LOG);
    ObjectGuid targetGuid = Target;
    ObjectGuid playerGuid = GetPlayer()->GetGUID(); // Sent twice
    ObjectGuid casterGuid = Caster;

    data.WriteBit(1);               // Unk but always sent, sniffed from retail
    data.WriteBit(playerGuid[6]);
    data.WriteBit(casterGuid[6]);
    data.WriteBit(playerGuid[5]);
    data.WriteBit(casterGuid[0]);

    {
        data.WriteBit(playerGuid[1]);
        data.WriteBit(playerGuid[4]);
        data.WriteBit(playerGuid[5]);
        data.WriteBit(playerGuid[2]);
        data.WriteBit(playerGuid[6]);
        data.WriteBits(1, 21);          // Unk but always sent, sniffed from retail
        data.WriteBit(playerGuid[3]);
        data.WriteBit(playerGuid[0]);
        data.WriteBit(playerGuid[7]);
    }

    data.WriteBit(playerGuid[4]);
    data.WriteBit(targetGuid[1]);
    data.WriteBit(targetGuid[6]);
    data.WriteBit(targetGuid[3]);
    data.WriteBit(targetGuid[7]);
    data.WriteBit(casterGuid[7]);
    data.WriteBit(casterGuid[1]);
    data.WriteBit(targetGuid[4]);
    data.WriteBit(casterGuid[5]);
    data.WriteBit(playerGuid[0]);
    data.WriteBit(targetGuid[0]);
    data.WriteBit(playerGuid[3]);
    data.WriteBit(playerGuid[1]);
    data.WriteBit(casterGuid[3]);
    data.WriteBit(targetGuid[5]);
    data.WriteBit(playerGuid[7]);
    data.WriteBit(casterGuid[4]);
    data.WriteBit(targetGuid[2]);
    data.WriteBit(playerGuid[2]);
    data.WriteBit(casterGuid[2]);

    {
        data.WriteByteSeq(playerGuid[3]);
        data.WriteByteSeq(playerGuid[2]);
        data.WriteByteSeq(playerGuid[6]);
        data << uint32(522093);         // Unk but always sent, sniffed from retail

        data << uint32(0);              // Unk but always sent, sniffed from retail
        data << uint32(60000);          // Unk but always sent, sniffed from retail

        data.WriteByteSeq(playerGuid[0]);
        data.WriteByteSeq(playerGuid[4]);
        data.WriteByteSeq(playerGuid[7]);
        data.WriteByteSeq(playerGuid[1]);
        data << uint32(107);            // Unk but always sent, sniffed from retail
        data.WriteByteSeq(playerGuid[5]);
        data << uint32(24528);          // Unk but always sent, sniffed from retail
    }

    data.WriteByteSeq(casterGuid[4]);
    data.WriteByteSeq(casterGuid[2]);
    data.WriteByteSeq(targetGuid[5]);
    data.WriteByteSeq(targetGuid[4]);
    data << uint32(slotID);
    data.WriteByteSeq(targetGuid[2]);
    data.WriteByteSeq(playerGuid[2]);
    data.WriteByteSeq(targetGuid[1]);
    data.WriteByteSeq(playerGuid[0]);
    data.WriteByteSeq(targetGuid[0]);
    data.WriteByteSeq(targetGuid[7]);
    data.WriteByteSeq(playerGuid[6]);
    data << uint32(ItemID);
    data.WriteByteSeq(targetGuid[3]);
    data.WriteByteSeq(playerGuid[7]);
    data.WriteByteSeq(playerGuid[1]);
    data.WriteByteSeq(casterGuid[1]);
    data.WriteByteSeq(casterGuid[5]);
    data.WriteByteSeq(casterGuid[6]);
    data.WriteByteSeq(playerGuid[4]);
    data.WriteByteSeq(casterGuid[0]);
    data.WriteByteSeq(playerGuid[5]);
    data.WriteByteSeq(playerGuid[3]);
    data.WriteByteSeq(casterGuid[7]);
    data << uint32(enchantID);
    data.WriteByteSeq(targetGuid[6]);
    data.WriteByteSeq(casterGuid[3]);

    SendPacket(&data);
}

void WorldSession::SendItemEnchantTimeUpdate(uint64 Playerguid, uint64 Itemguid, uint32 slot, uint32 Duration)
{
    WorldPacket data(SMSG_ITEM_ENCHANT_TIME_UPDATE);
    ObjectGuid itemGuid = Itemguid;
    ObjectGuid playerGuid = Playerguid;

    data.WriteBit(itemGuid[3]);
    data.WriteBit(playerGuid[4]);
    data.WriteBit(itemGuid[0]);
    data.WriteBit(playerGuid[7]);
    data.WriteBit(itemGuid[2]);
    data.WriteBit(playerGuid[6]);
    data.WriteBit(itemGuid[6]);
    data.WriteBit(itemGuid[1]);
    data.WriteBit(playerGuid[2]);
    data.WriteBit(itemGuid[7]);
    data.WriteBit(playerGuid[3]);
    data.WriteBit(playerGuid[1]);
    data.WriteBit(itemGuid[5]);
    data.WriteBit(playerGuid[5]);
    data.WriteBit(playerGuid[0]);
    data.WriteBit(itemGuid[4]);

    data << uint32(Duration);
    data.WriteByteSeq(playerGuid[2]);
    data.WriteByteSeq(playerGuid[3]);
    data.WriteByteSeq(itemGuid[7]);
    data.WriteByteSeq(playerGuid[0]);
    data << uint32(slot);
    data.WriteByteSeq(itemGuid[3]);
    data.WriteByteSeq(playerGuid[6]);
    data.WriteByteSeq(itemGuid[6]);
    data.WriteByteSeq(itemGuid[4]);
    data.WriteByteSeq(itemGuid[2]);
    data.WriteByteSeq(playerGuid[1]);
    data.WriteByteSeq(itemGuid[5]);
    data.WriteByteSeq(playerGuid[5]);
    data.WriteByteSeq(playerGuid[4]);
    data.WriteByteSeq(playerGuid[7]);
    data.WriteByteSeq(itemGuid[0]);
    data.WriteByteSeq(itemGuid[1]);

    SendPacket(&data);
}

void WorldSession::HandleWrapItemOpcode(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_WRAP_ITEM");

    bool hasGiftBag, hasGiftSlot, hasItemBag, hasItemSlot;
    uint8 gift_bag = 0;
    uint8 gift_slot = 0;
    uint8 item_bag = 0;
    uint8 item_slot = 0;

    uint8 itemCount = recvData.ReadBits(2);

    for (uint8 i = 0; i < itemCount; ++i)
    {
        if (i == 0)
        {
            hasGiftBag = !recvData.ReadBit();
            hasGiftSlot = !recvData.ReadBit();
        }
        else
        {
            hasItemBag = !recvData.ReadBit();
            hasItemSlot = !recvData.ReadBit();
        }
    }

    recvData.FlushBits();

    for (uint8 i = 0; i < itemCount; ++i)
    {
        if (i == 0)
        {
            if (hasGiftSlot)
                recvData >> gift_slot;

            if (hasGiftBag)
                recvData >> gift_bag;
        }
        else
        {
            if (hasItemSlot)
                recvData >> item_slot;

            if (hasItemBag)
                recvData >> item_bag;
        }
    }

    sLog->outDebug(LOG_FILTER_NETWORKIO, "WRAP: receive gift_bag = %u, gift_slot = %u, item_bag = %u, item_slot = %u", gift_bag, gift_slot, item_bag, item_slot);

    Item* gift = m_Player->GetItemByPos(gift_bag, gift_slot);
    if (!gift)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    if (!(gift->GetTemplate()->Flags & ITEM_PROTO_FLAG_WRAPPER)) // cheating: non-wrapper wrapper
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    Item* item = m_Player->GetItemByPos(item_bag, item_slot);

    if (!item)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, item, NULL);
        return;
    }

    if (item == gift)                                          // not possable with pacjket from real client
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsEquipped())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_EQUIPPED, item, NULL);
        return;
    }

    if (item->GetUInt64Value(ITEM_FIELD_GIFT_CREATOR))        // HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_WRAPPED);
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsBag())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_BAGS, item, NULL);
        return;
    }

    if (item->IsSoulBound())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_BOUND, item, NULL);
        return;
    }

    if (item->GetMaxStackCount() != 1)
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_STACKABLE, item, NULL);
        return;
    }

    // maybe not correct check  (it is better than nothing)
    if (item->GetTemplate()->MaxCount > 0 || item->IsConjuredConsumable())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_UNIQUE, item, NULL);
        return;
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GIFT);
    stmt->setUInt32(0, GUID_LOPART(item->GetOwnerGUID()));
    stmt->setUInt32(1, item->GetGUIDLow());
    stmt->setUInt32(2, item->GetEntry());
    stmt->setUInt32(3, item->GetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS));
    trans->Append(stmt);

    item->SetEntry(gift->GetEntry());

    switch (item->GetEntry())
    {
        case 5042:
            item->SetEntry(5043);
            break;
        case 5048:
            item->SetEntry(5044);
            break;
        case 17303:
            item->SetEntry(17302);
            break;
        case 17304:
            item->SetEntry(17305);
            break;
        case 17307:
            item->SetEntry(17308);
            break;
        case 21830:
            item->SetEntry(21831);
            break;
    }

    item->SetUInt64Value(ITEM_FIELD_GIFT_CREATOR, m_Player->GetGUID());
    item->SetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_WRAPPED);
    item->SetState(ITEM_CHANGED, m_Player);

    if (item->GetState() == ITEM_NEW)                          // save new item, to have alway for `character_gifts` record in `item_instance`
    {
        // after save it will be impossible to remove the item from the queue
        item->RemoveFromUpdateQueueOf(m_Player);
        item->SaveToDB(trans);                                   // item gave inventory record unchanged and can be save standalone
    }

    CharacterDatabase.CommitTransaction(trans);

    uint32 count = 1;
    m_Player->DestroyItemCount(gift, count, true);
}

void WorldSession::HandleSocketOpcode(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_SOCKET_GEMS");

    ObjectGuid item_guid;
    ObjectGuid gem_guids[MAX_GEM_SOCKETS];

    item_guid[3] = recvData.ReadBit();

    // The next is totally fucked up ... Thanks blizzard !
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][1] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][5] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][6] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][4] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][7] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][0] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][3] = recvData.ReadBit();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][2] = recvData.ReadBit();

    item_guid[0] = recvData.ReadBit();
    item_guid[7] = recvData.ReadBit();
    item_guid[5] = recvData.ReadBit();
    item_guid[2] = recvData.ReadBit();
    item_guid[6] = recvData.ReadBit();
    item_guid[4] = recvData.ReadBit();
    item_guid[1] = recvData.ReadBit();

    recvData.FlushBits();

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][6]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][7]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][4]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][3]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][2]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][1]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][5]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][0]);

    uint8 bytesOrder[8] = { 7, 2, 6, 0, 5, 4, 1, 3 };
    recvData.ReadBytesSeq(item_guid, bytesOrder);

    if (!item_guid)
        return;

    // Cheat -> tried to socket same gem multiple times
    if ((gem_guids[0] && (gem_guids[0] == gem_guids[1] || gem_guids[0] == gem_guids[2])) ||
        (gem_guids[1] && (gem_guids[1] == gem_guids[2])))
        return;

    // Missing item to socket
    Item* itemTarget = m_Player->GetItemByGuid(item_guid);
    if (!itemTarget)
        return;

    ItemTemplate const* itemProto = itemTarget->GetTemplate();
    if (!itemProto)
        return;

    // This slot is excepted when applying / removing meta gem bonus
    uint8 slot = itemTarget->IsEquipped() ? itemTarget->GetSlot() : uint8(NULL_SLOT);

    Item* Gems[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        Gems[i] = gem_guids[i] ? m_Player->GetItemByGuid(gem_guids[i]) : NULL;

    // Get geminfo from dbc storage
    GemPropertiesEntry const* GemProps[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        GemProps[i] = (Gems[i]) ? sGemPropertiesStore.LookupEntry(Gems[i]->GetTemplate()->GemProperties) : NULL;

    // Check for hack maybe
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!GemProps[i])
            continue;

        // Tried to put gem in socket where no socket exists (take care about prismatic sockets)
        if (!itemProto->Socket[i].Color)
        {
            // No prismatic socket
            if (!itemTarget->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
                return;

            // Not first not-colored (not normaly used) socket
            if (i != 0 && !itemProto->Socket[i-1].Color && (i+1 >= MAX_GEM_SOCKETS || itemProto->Socket[i+1].Color))
                return;

            // Ok, this is first not colored socket for item with prismatic socket
        }

        // Tried to put normal gem in meta socket
        if (itemProto->Socket[i].Color == SOCKET_COLOR_META && GemProps[i]->color != SOCKET_COLOR_META)
            return;

        // Tried to put meta gem in normal socket
        if (itemProto->Socket[i].Color != SOCKET_COLOR_META && GemProps[i]->color == SOCKET_COLOR_META)
            return;

        // Tried to put normal gem in cogwheel socket
        if (itemProto->Socket[i].Color == SOCKET_COLOR_COGWHEEL && GemProps[i]->color != SOCKET_COLOR_COGWHEEL)
            return;

        // Tried to put cogwheel gem in normal socket
        if (itemProto->Socket[i].Color != SOCKET_COLOR_COGWHEEL && GemProps[i]->color == SOCKET_COLOR_COGWHEEL)
            return;
    }

    // Get new and old enchantments
    uint32 GemEnchants[MAX_GEM_SOCKETS];
    uint32 OldEnchants[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        GemEnchants[i] = (GemProps[i]) ? GemProps[i]->spellitemenchantement : 0;
        OldEnchants[i] = itemTarget->GetEnchantmentId(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i));
    }

    // Check unique-equipped conditions
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!Gems[i])
            continue;

        // Continue check for case when attempt add 2 similar unique equipped gems in one item.
        ItemTemplate const* iGemProto = Gems[i]->GetTemplate();

        // Unique item (for new and already placed bit removed enchantments
        if (iGemProto->Flags & ITEM_PROTO_FLAG_UNIQUE_EQUIPPED)
        {
            for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
            {
                // Skip self
                if (i == j)
                    continue;

                if (Gems[j])
                {
                    if (iGemProto->ItemId == Gems[j]->GetEntry())
                    {
                        m_Player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                        return;
                    }
                }
                else if (OldEnchants[j])
                {
                    if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                    {
                        if (iGemProto->ItemId == enchantEntry->GemID)
                        {
                            m_Player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                            return;
                        }
                    }
                }
            }
        }

        // Unique limit type item
        int32 limit_newcount = 0;
        if (iGemProto->ItemLimitCategory)
        {
            if (ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(iGemProto->ItemLimitCategory))
            {
                // NOTE: limitEntry->mode is not checked because if item has limit then it is applied in equip case
                for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
                {
                    if (Gems[j])
                    {
                        // New gem
                        if (iGemProto->ItemLimitCategory == Gems[j]->GetTemplate()->ItemLimitCategory)
                            ++limit_newcount;
                    }
                    else if (OldEnchants[j])
                    {
                        // Existing gem
                        if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                            if (ItemTemplate const* jProto = sObjectMgr->GetItemTemplate(enchantEntry->GemID))
                                if (iGemProto->ItemLimitCategory == jProto->ItemLimitCategory)
                                    ++limit_newcount;
                    }
                }

                if (limit_newcount > 0 && uint32(limit_newcount) > limitEntry->maxCount)
                {
                    m_Player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                    return;
                }
            }
        }

        // For equipped item check all equipment for duplicate equipped gems
        if (itemTarget->IsEquipped())
        {
            if (InventoryResult res = m_Player->CanEquipUniqueItem(Gems[i], slot, std::max(limit_newcount, 0)))
            {
                m_Player->SendEquipError(res, itemTarget, NULL);
                return;
            }
        }
    }

    // Save state of socketbonus
    bool SocketBonusActivated = itemTarget->GemsFitSockets();
    // Turn off all metagems (except for the target item)
    m_Player->ToggleMetaGemsActive(slot, false);

    // If a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met
    // Remove ALL enchants
    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
        m_Player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), false);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (GemEnchants[i])
        {
            uint32 gemCount = 1;
            itemTarget->SetEnchantment(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i), GemEnchants[i], 0, 0);
            if (Item* guidItem = m_Player->GetItemByGuid(gem_guids[i]))
                m_Player->DestroyItemCount(guidItem, gemCount, true);
        }
    }

    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+MAX_GEM_SOCKETS; ++enchant_slot)
        m_Player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), true);

    // Current socketbonus state
    bool SocketBonusToBeActivated = itemTarget->GemsFitSockets();
    uint32 socketBonus = 0;

    // If there was a change...
    if (SocketBonusActivated ^ SocketBonusToBeActivated)
    {
        socketBonus = SocketBonusToBeActivated ? itemTarget->GetTemplate()->socketBonus : 0;

        m_Player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, false);
        itemTarget->SetEnchantment(BONUS_ENCHANTMENT_SLOT, socketBonus, 0, 0);
        m_Player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, true);
        // It is not displayed, client has an inbuilt system to determine if the bonus is activated
    }

    // Turn on all metagems (except for target item)
    m_Player->ToggleMetaGemsActive(slot, true);
    m_Player->RemoveTradeableItem(itemTarget);
    // Clear tradeable flag
    itemTarget->ClearSoulboundTradeable(m_Player);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        if (GemEnchants[i])
            m_Player->GetSession()->SendEnchantmentLog(itemTarget->GetGUID(), m_Player->GetGUID(), itemTarget->GetEntry(), GemEnchants[i], SOCK_ENCHANTMENT_SLOT+i);

    if (socketBonus)
        m_Player->GetSession()->SendEnchantmentLog(itemTarget->GetGUID(), m_Player->GetGUID(), itemTarget->GetEntry(), socketBonus, BONUS_ENCHANTMENT_SLOT);

    WorldPacket data(SMSG_SOCKET_GEMS, 4 * 4 + 8);

    data << uint32(socketBonus);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (GemEnchants[i])
            data << uint32(GemEnchants[i]);
        else
            data << uint32(0);
    }

    uint8 bitsOrder[8] = { 1, 7, 5, 6, 0, 2, 4, 3 };
    data.WriteBitInOrder(item_guid, bitsOrder);

    uint8 bytesSendedOrder[8] = { 0, 5, 2, 6, 7, 4, 3, 1 };
    data.WriteBytesSeq(item_guid, bytesSendedOrder);

    GetPlayer()->GetSession()->SendPacket(&data);
}

void WorldSession::HandleCancelTempEnchantmentOpcode(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_CANCEL_TEMP_ENCHANTMENT");

    uint32 slot;

    recvData >> slot;

    // apply only to equipped item
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
        return;

    Item* item = GetPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

    if (!item)
        return;

    if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
        return;

    GetPlayer()->ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
    item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
}

void WorldSession::HandleItemRefundInfoRequest(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_ITEM_REFUND_INFO");

    ObjectGuid guid;

    uint8 bitsOrder[8] = { 7, 6, 0, 4, 5, 3, 2, 1 };
    recvData.ReadBitInOrder(guid, bitsOrder);

    recvData.FlushBits();

    uint8 bytesOrder[8] = { 2, 0, 3, 1, 6, 7, 4, 5 };
    recvData.ReadBytesSeq(guid, bytesOrder);

    Item* item = m_Player->GetItemByGuid(guid);
    if (!item)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "Item refund: item not found!");
        return;
    }

    GetPlayer()->SendRefundInfo(item);
}

void WorldSession::HandleItemRefund(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_ITEM_REFUND");

    ObjectGuid itemGuid;

    uint8 bitsOrder[8] = { 4, 7, 6, 5, 0, 3, 2, 1 };
    recvData.ReadBitInOrder(itemGuid, bitsOrder);

    recvData.FlushBits();

    uint8 bytesOrder[8] = { 2, 1, 4, 3, 5, 6, 0, 7 };
    recvData.ReadBytesSeq(itemGuid, bytesOrder);

    Item* item = m_Player->GetItemByGuid(itemGuid);
    if (!item)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "Item refund: item not found!");
        return;
    }

    GetPlayer()->RefundItem(item);
}

/**
 * Handles the packet sent by the client when requesting information about item text.
 *
 * This function is called when player clicks on item which has some flag set
 */
void WorldSession::HandleItemTextQuery(WorldPacket& recvData )
{
    uint64 itemGuid;
    recvData >> itemGuid;

    sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_ITEM_TEXT_QUERY item guid: %u", GUID_LOPART(itemGuid));

    WorldPacket data(SMSG_ITEM_TEXT_QUERY_RESPONSE, 14);    // guess size

    if (Item* item = m_Player->GetItemByGuid(itemGuid))
    {
        data << uint8(0);                                       // has text
        data << uint64(itemGuid);                               // item guid
        data << item->GetText();
    }
    else
    {
        data << uint8(1);                                       // no text
    }

    SendPacket(&data);
}

void WorldSession::HandleTransmogrifyItems(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_TRANSMOGRIFY_ITEMS");

    Player* player = GetPlayer();
    ObjectGuid npcGuid;

    uint8 bitsNpcOrder[8] = { 2, 0, 5, 3, 7, 1, 6, 4 };
    recvData.ReadBitInOrder(npcGuid, bitsNpcOrder);

    // Read data
    uint32 count = recvData.ReadBits(21);

    if (count < EQUIPMENT_SLOT_START || count >= EQUIPMENT_SLOT_END)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) sent a wrong count (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName(), count);
        recvData.rfinish();
        return;
    }

    std::vector<ObjectGuid> itemGuids(count, ObjectGuid(0));
    std::vector<ObjectGuid> unkGuids(count, ObjectGuid(0));
    std::vector<uint32> newEntries(count, 0);
    std::vector<uint32> slots(count, 0);
    std::vector<bool> hasItemGuid(count, false);
    std::vector<bool> hasUnkGuid(count, false);

    for (uint8 i = 0; i < count; ++i)
    {
        hasUnkGuid[i] = recvData.ReadBit();
        hasItemGuid[i] = recvData.ReadBit();

        if (hasItemGuid[i])
        {
            uint8 bitsOrder[8] = { 2, 3, 4, 1, 7, 6, 5, 0 };
            recvData.ReadBitInOrder(itemGuids[i], bitsOrder);
        }

        if (hasUnkGuid[i])
        {
            uint8 bitsOrder[8] = { 3, 1, 5, 6, 2, 0, 4, 7 };
            recvData.ReadBitInOrder(unkGuids[i], bitsOrder);
        }
    }

    recvData.FlushBits();

    for (uint32 i = 0; i < count; ++i)
    {
        recvData >> newEntries[i];
        recvData >> slots[i];
    }

    uint8 bytesNpcOrder[8] = { 3, 2, 6, 5, 0, 1, 4, 7 };
    recvData.ReadBytesSeq(npcGuid, bytesNpcOrder);

    for (uint32 i = 0; i < count; ++i)
    {
        if (hasUnkGuid[i])
        {
            uint8 bytesOrder[8] = { 0, 7, 5, 2, 4, 1, 3, 6 };
            recvData.ReadBytesSeq(unkGuids[i], bytesOrder);
        }

        if (hasItemGuid[i])
        {
            uint8 bytesOrder[8] = { 5, 4, 0, 7, 6, 3, 1, 2 };
            recvData.ReadBytesSeq(itemGuids[i], bytesOrder);
        }
    }

    // Validate
    if (!player->GetNPCIfCanInteractWith(npcGuid, UNIT_NPC_FLAG_TRANSMOGRIFIER))
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(npcGuid));
        return;
    }

    float cost = 0;
    for (uint8 i = 0; i < count; ++i)
    {
        // slot of the transmogrified item
        if (slots[i] < EQUIPMENT_SLOT_START || slots[i] >= EQUIPMENT_SLOT_END)
        {
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an item (lowguid: %u) with a wrong slot (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName(), GUID_LOPART(itemGuids[i]), slots[i]);
            return;
        }

        // entry of the transmogrifier item, if it's not 0
        if (newEntries[i])
        {
            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(newEntries[i]);
            if (!proto)
            {
                sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify to an invalid item (entry: %u).", player->GetGUIDLow(), player->GetName(), newEntries[i]);
                return;
            }

            if (!player->HasItemCount(newEntries[i], 1, false))
                return;
        }

        Item* itemTransmogrifier = NULL;
        // guid of the transmogrifier item, if it's not 0
        if (itemGuids[i])
        {
            itemTransmogrifier = player->GetItemByGuid(itemGuids[i]);
            if (!itemTransmogrifier)
            {
                sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify with an invalid item (lowguid: %u).", player->GetGUIDLow(), player->GetName(), GUID_LOPART(itemGuids[i]));
                return;
            }
        }

        // transmogrified item
        Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]);
        if (!itemTransmogrified)
        {
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetGUIDLow(), player->GetName(), slots[i]);
            return;
        }

        if (!newEntries[i]) // reset look
        {
            itemTransmogrified->SetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 1, 0);
            itemTransmogrified->RemoveFlag(ITEM_FIELD_MODIFIERS_MASK, 2);
            player->SetVisibleItemSlot(slots[i], itemTransmogrified);
        }
        else
        {
            if (!itemTransmogrifier)
                return;

            if (!Item::CanTransmogrifyItemWithItem(itemTransmogrified, itemTransmogrifier))
            {
                sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetGUIDLow(), player->GetName(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
                return;
            }

            // All okay, proceed
            itemTransmogrified->SetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 1, newEntries[i]);
            itemTransmogrified->SetFlag(ITEM_FIELD_MODIFIERS_MASK, 2);
            player->SetVisibleItemSlot(slots[i], itemTransmogrified);

            itemTransmogrified->UpdatePlayedTime(player);

            itemTransmogrified->SetOwnerGUID(player->GetGUID());
            itemTransmogrified->SetNotRefundable(player);
            itemTransmogrified->ClearSoulboundTradeable(player);

            if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
                itemTransmogrifier->SetBinding(true);

            itemTransmogrifier->SetOwnerGUID(player->GetGUID());
            itemTransmogrifier->SetNotRefundable(player);
            itemTransmogrifier->ClearSoulboundTradeable(player);

            cost += itemTransmogrified->GetSpecialPrice();
        }
    }

    float costModifier = 1.0f;
    Unit::AuraEffectList const& mModModifyPrice = player->GetAuraEffectsByType(SPELL_AURA_REDUCE_ITEM_MODIFY_COST);
    for (Unit::AuraEffectList::const_iterator i = mModModifyPrice.begin(); i != mModModifyPrice.end(); ++i)
        costModifier += float(float((*i)->GetAmount()) / 100.0f);

    cost *= costModifier;

    // trusting the client, if it got here it has to have enough money
    // ... unless client was modified
    if (cost) // 0 cost if reverting look
        player->ModifyMoney(-int64(cost));
}

void WorldSession::HandleChangeCurrencyFlags(WorldPacket& recvPacket)
{
    uint32 currencyId, flags;

    recvPacket >> flags >> currencyId;

    if (GetPlayer())
        GetPlayer()->ModifyCurrencyFlags(currencyId, uint8(flags));
}

void WorldSession::SendItemUpgradeResult(bool success)
{
    WorldPacket data(SMSG_ITEM_UPGRADE_RESULT, 1);
    data.WriteBit(success);
    data.FlushBits();
    SendPacket(&data);
}

void WorldSession::HandleUpgradeItemOpcode(WorldPacket& recvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_UPGRADE_ITEM");

    ObjectGuid npcGuid;
    ObjectGuid itemGuid;
    Player* player = GetPlayer();

    uint32 item_slot = 0;
    uint32 upgradeEntry = 0;
    uint32 item_bag = 0;
    recvData >> item_slot >> upgradeEntry >> item_bag;

    npcGuid[6] = recvData.ReadBit();
    itemGuid[4] = recvData.ReadBit();
    itemGuid[3] = recvData.ReadBit();
    itemGuid[5] = recvData.ReadBit();
    npcGuid[5] = recvData.ReadBit();
    itemGuid[1] = recvData.ReadBit();
    npcGuid[7] = recvData.ReadBit();
    npcGuid[3] = recvData.ReadBit();
    itemGuid[6] = recvData.ReadBit();
    itemGuid[2] = recvData.ReadBit();
    npcGuid[2] = recvData.ReadBit();
    npcGuid[4] = recvData.ReadBit();
    itemGuid[7] = recvData.ReadBit();
    npcGuid[1] = recvData.ReadBit();
    npcGuid[0] = recvData.ReadBit();
    itemGuid[0] = recvData.ReadBit();

    recvData.FlushBits();

    recvData.ReadByteSeq(itemGuid[4]);
    recvData.ReadByteSeq(itemGuid[5]);
    recvData.ReadByteSeq(npcGuid[3]);
    recvData.ReadByteSeq(npcGuid[0]);
    recvData.ReadByteSeq(itemGuid[1]);
    recvData.ReadByteSeq(itemGuid[3]);
    recvData.ReadByteSeq(itemGuid[7]);
    recvData.ReadByteSeq(npcGuid[7]);
    recvData.ReadByteSeq(npcGuid[6]);
    recvData.ReadByteSeq(itemGuid[2]);
    recvData.ReadByteSeq(npcGuid[1]);
    recvData.ReadByteSeq(npcGuid[4]);
    recvData.ReadByteSeq(npcGuid[5]);
    recvData.ReadByteSeq(itemGuid[0]);
    recvData.ReadByteSeq(itemGuid[6]);
    recvData.ReadByteSeq(npcGuid[2]);

    if (!player->GetNPCIfCanInteractWithFlag2(npcGuid, UNIT_NPC_FLAG2_ITEM_UPGRADE))
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(npcGuid));
        SendItemUpgradeResult(false);
        return;
    }

    Item* item = player->GetItemByGuid(itemGuid);
    if (!item)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    // Check if item guid is the same as item related to bag and slot
    if (Item* tempItem = player->GetItemByPos(item_bag, item_slot))
    {
        if (item != tempItem)
        {
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
            SendItemUpgradeResult(false);
            return;
        }
    }
    else
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    ItemUpgradeEntry const* itemUpEntry = sItemUpgradeStore.LookupEntry(upgradeEntry);
    if (!itemUpEntry)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) not found.", upgradeEntry);
        SendItemUpgradeResult(false);
        return;
    }

    // Check if player has enough currency
    if (player->GetCurrency(itemUpEntry->currencyId, false) < itemUpEntry->currencyCost)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Player has not enougth currency (ID: %u, Cost: %u) not found.", itemUpEntry->currencyId, itemUpEntry->currencyCost);
        SendItemUpgradeResult(false);
        return;
    }

    uint32 actualUpgrade = item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 2);
    if (actualUpgrade != itemUpEntry->precItemUpgradeId)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) is not related to this ItemUpgradePath (%u).", itemUpEntry->Id, actualUpgrade);
        SendItemUpgradeResult(false);
        return;
    }

    item->SetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 2, itemUpEntry->Id);
    item->SetFlag(ITEM_FIELD_MODIFIERS_MASK, 0x1 | 0x2 | 0x4);
    item->SetState(ITEM_CHANGED, player);

    // Don't forget to remove currency cost
    SendItemUpgradeResult(true);

    //if (item->IsEquipped())
    //    player->ApplyItemUpgrade(item, true);

    player->ModifyCurrency(itemUpEntry->currencyId, -int32(itemUpEntry->currencyCost), false, true, true);
}

void WorldSession::HandleSetLootSpecialization(WorldPacket& p_RecvData)
{
    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_SET_LOOT_SPECIALIZATION");

    uint32 l_SpecID = p_RecvData.read<uint32>();
    GetPlayer()->SetLootSpecId(l_SpecID);
    GetPlayer()->SetUInt32Value(PLAYER_FIELD_LOOT_SPEC_ID, l_SpecID);
}
